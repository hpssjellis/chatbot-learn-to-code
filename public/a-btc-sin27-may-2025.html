<html>
  <head>
    <title>Vibe Coding BTC Sinusoids</title>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <style>
      body {
        font-family: sans-serif;
        margin: 20px;
      }
      .controls {
        text-align: center;
        margin-bottom: 20px;
      }
      .controls input[type="button"]:hover {
        background-color: #2980b9;
      }
      .controls input[type="button"]:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }
      .wave-group {
        border: 1px solid #ccc;
        padding: 10px;
        margin: 10px auto;
        width: fit-content;
        display: inline-block;
        vertical-align: top;
      }
      .wave-group label {
        display: inline-block;
        width: 120px;
        text-align: right;
        margin-right: 5px;
      }
      .wave-group input {
        margin-bottom: 5px;
      }
      .top-parameters-group {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 20px;
      }
    </style>
  </head>
  <body>
    <h3 style="text-align: center;">Vibe Coding BTC Sinusoids</h3>
  The <a href="https://charts.bitbo.io/long-term-power-law/">power-law BTC equation</a>a> plotting BTC on a price-date log-log graph with max-min parameters. Is interesting, 
    but anyone should be able to see the complex sinusoidal potential in that graph. This is just an attempt to give people their own control of this complexity. 

    <div class="controls">
      <input type="button" id="fitBtn" value="Fit to BTC Data" onclick="fitToBTCData()" style="padding: 8px 15px; cursor: pointer;">
      <input type="button" id="fftBtn" value="FFT on BTC" onclick="updateSinusoidsWithFFTAnalysis()" style="padding: 8px 15px; cursor: pointer;">
      
      <div id="statusMessage" style="margin-top: 10px; font-weight: bold;"></div>
      <br>

      <div class="top-parameters-group">
        <div style="border: 1px solid #ccc; padding: 10px; width: fit-content;">
          <h4>QCBD Parameters <small>(Quantum Crypto Breaking Date)</small></h4>
          <label>QCBD Year:</label>
          <input type="text" id="qcbDateInput" value="2030.0" size="8" onchange="qcbDateYear = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Social Distrust (Crash Target):</label> <input type="text" id="socialDistrustValueInput" value="500" size="10" onchange="socialDistrustValue = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>QCBD Transition (Years):</label>
          <input type="text" id="qcbTransitionInput" value="0.5" size="6" onchange="qcbTransitionDuration = parseFloat(this.value); myGenerateLogLogData();"><br>
        </div>
        <div style="border: 1px solid #ccc; padding: 10px; width: fit-content;">
          <h4>Independent Power Law Parameters <small>(Not Affecting Combined Line)</small></h4>
          <label>Constant:</label>
          <input type="text" id="powerLawConstantInput" value="3.147e-173" size="15" onchange="powerLawConstant = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Exponent:</label>
          <input type="text" id="powerLawExponentInput" value="41.2" size="10" onchange="powerLawExponent = parseFloat(this.value); myGenerateLogLogData();">
        </div>
      </div>

      <div style="display: flex; justify-content: center; flex-wrap: wrap;">
        <div class="wave-group">
          <h4>Wave 1</h4>
          <label>Frequency:</label>
          <input type="text" value="7" size="6" id="wave1FreqInput" onchange="wave1Freq = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Amplitude:</label>
          <input type="text" value="10000" size="6" id="wave1AmpInput" onchange="wave1Amp = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Offset from Exp Baseline:</label>
          <input type="text" value="0.0" size="6" id="wave1YShiftInput" onchange="wave1YShift = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Phase (radians):</label>
          <input type="text" value="0.0" size="6" id="wave1PhaseInput" onchange="wave1Phase = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Freq Growth Factor:</label>
          <input type="text" value="0.0" size="6" id="wave1FreqGrowthInput" onchange="wave1FreqGrowth = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Amp Growth Factor:</label>
          <input type="text" value="0.1" size="6" id="wave1AmpGrowthInput" onchange="wave1AmpGrowth = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Amp Growth Strength:</label>
          <input type="text" value="1.0" size="6" id="wave1AmpGrowthStrengthInput" onchange="wave1AmpGrowthStrength = parseFloat(this.value); myGenerateLogLogData();"><br>
          <hr>
          <label>Exponential Base:</label>
          <input type="text" value="1.0" size="6" id="wave1ExpBaseInput" onchange="wave1ExpBase = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Exp Growth Factor:</label>
          <input type="text" value="0.1" size="6" id="wave1ExpGrowthInput" onchange="wave1ExpGrowth = parseFloat(this.value); myGenerateLogLogData();"><br>
        </div>

        <div class="wave-group">
          <h4>Wave 2</h4>
          <label>Frequency:</label>
          <input type="text" value="77" size="6" id="wave2FreqInput" onchange="wave2Freq = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Amplitude:</label>
          <input type="text" value="5000" size="6" id="wave2AmpInput" onchange="wave2Amp = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Offset from Exp Baseline:</label>
          <input type="text" value="0.0" size="6" id="wave2YShiftInput" onchange="wave2YShift = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Phase (radians):</label>
          <input type="text" value="0.0" size="6" id="wave2PhaseInput" onchange="wave2Phase = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Freq Growth Factor:</label>
          <input type="text" value="0.0" size="6" id="wave2FreqGrowthInput" onchange="wave2FreqGrowth = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Amp Growth Factor:</label>
          <input type="text" value="0.1" size="6" id="wave2AmpGrowthInput" onchange="wave2AmpGrowth = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Amp Growth Strength:</label>
          <input type="text" value="1.0" size="6" id="wave2AmpGrowthStrengthInput" onchange="wave2AmpGrowthStrength = parseFloat(this.value); myGenerateLogLogData();"><br>
          <hr>
          <label>Exponential Base:</label>
          <input type="text" value="1.0" size="6" id="wave2ExpBaseInput" onchange="wave2ExpBase = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Exp Growth Factor:</label>
          <input type="text" value="1.0" size="6" id="wave2ExpGrowthInput" onchange="wave2ExpGrowth = parseFloat(this.value); myGenerateLogLogData();"><br>
        </div>

        <div class="wave-group">
          <h4>Wave 3</h4>
          <label>Frequency:</label>
          <input type="text" value="777" size="6" id="wave3FreqInput" onchange="wave3Freq = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Amplitude:</label>
          <input type="text" value="5000" size="6" id="wave3AmpInput" onchange="wave3Amp = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Offset from Exp Baseline:</label>
          <input type="text" value="0.0" size="6" id="wave3YShiftInput" onchange="wave3YShift = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Phase (radians):</label>
          <input type="text" value="0.0" size="6" id="wave3PhaseInput" onchange="wave3Phase = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Freq Growth Factor:</label>
          <input type="text" value="0.0" size="6" id="wave3FreqGrowthInput" onchange="wave3FreqGrowth = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Amp Growth Factor:</label>
          <input type="text" value="0.1" size="6" id="wave3AmpGrowthInput" onchange="wave3AmpGrowth = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Amp Growth Strength:</label>
          <input type="text" value="1.0" size="6" id="wave3AmpGrowthStrengthInput" onchange="wave3AmpGrowthStrength = parseFloat(this.value); myGenerateLogLogData();"><br>
          <hr>
          <label>Exponential Base:</label>
          <input type="text" value="1.0" size="6" id="wave3ExpBaseInput" onchange="wave3ExpBase = parseFloat(this.value); myGenerateLogLogData();"><br>
          <label>Exp Growth Factor:</label>
          <input type="text" value="0.1" size="6" id="wave3ExpGrowthInput" onchange="wave3ExpGrowth = parseFloat(this.value); myGenerateLogLogData();"><br>
        </div>
      </div>
    </div>

    <div id="myPlot" style="width:90%; height:600px; margin: 0 auto;"></div>

    <script>
      // GLOBAL VARIABLES for sinusoidal model parameters - now individual variables for clarity
      let wave1Freq = 33; 
      let wave1Amp = 88;     
      let wave1YShift = 5555; // This now represents the desired offset from the exponential baseline
      let wave1Phase = 1.0;
      let wave1FreqGrowth = 0.6; 
      let wave1AmpGrowth = 32.0;    
      let wave1AmpGrowthStrength = 2.1; 
      let wave1ExpBase = 9.0; // NEW: Exponential base for Wave 1
      let wave1ExpGrowth = 99.0; // NEW: Exponential growth factor for Wave 1

      let wave2Freq = 99; 
      let wave2Amp = 8.0;     
      let wave2YShift = 2222.0; // This now represents the desired offset from the exponential baseline
      let wave2Phase = 2.0;
      let wave2FreqGrowth = 0.0; 
      let wave2AmpGrowth = 32.0;    
      let wave2AmpGrowthStrength = 3.0; 
      let wave2ExpBase = 7.0; // NEW: Exponential base for Wave 2
      let wave2ExpGrowth = 99.0; // NEW: Exponential growth factor for Wave 2

      let wave3Freq = 444;  
      let wave3Amp = 1.9;    
      let wave3YShift = 0.0; // This now represents the desired offset from the exponential baseline
      let wave3Phase = 0.0;
      let wave3FreqGrowth = 0.2; 
      let wave3AmpGrowth = 32.0;   
      let wave3AmpGrowthStrength = 3.1; 
      let wave3ExpBase = 9.0; // NEW: Exponential base for Wave 3
      let wave3ExpGrowth = 88.0; // NEW: Exponential growth factor for Wave 3

      // Global variables for QCBD and Social Distrust
      let qcbDateYear = 2029.8; 
      let socialDistrustValue = 500; 
      let qcbTransitionDuration = 0.5; 

      // These power law variables now control an *independent* trace, not the combined line's QCBD effect
      let powerLawConstant = 3.147e-173; 
      let powerLawExponent = 41.25; 

      // Global variable to store the BTC trace after it's fetched
      let btcTraceGlobal = null;
      let btcLogPricesGlobal = []; 
      let btcDatesGlobal = []; 

      /**
       * Calculates the value for the *separate* QCBD Crash line (red dashed).
       * This line visually represents the 'floor' or 'target' value the combined line
       * might crash towards after the QCBD year.
       * It's flat before QCBD year and then transitions to socialDistrustValue.
       * @param {number} year - The year for which to calculate the value.
       * @param {number} qcbYear - The QCBD year.
       * @param {number} socialDistrustVal - The social distrust value (the target floor).
       * @param {number} transitionDur - The transition duration in years.
       * @returns {number} The calculated value for the QCBD Crash line.
       */
      function getQCBDCrashLineValue(year, qcbYear, socialDistrustVal, transitionDur) {
          if (year < qcbYear) {
              return 0.001; // Effectively off the chart or minimal before QCBD
          } else {
              const transitionFactor = Math.min(1, (year - qcbYear) / transitionDur);
              // Smoothly transition from a low value to socialDistrustVal
              return 0.001 * (1 - transitionFactor) + socialDistrustVal * transitionFactor;
          }
      }

      /**
       * Calculates a transition factor (0 to 1) for the QCBD effect.
       * This factor determines how much the combined line transitions towards the socialDistrustValue.
       * @param {number} year - The current year.
       * @param {number} qcbYear - The QCBD year.
       * @param {number} transitionDur - The transition duration in years.
       * @returns {number} A factor between 0 and 1.
       */
      function getQCBDTransitionFactor(year, qcbYear, transitionDur) {
          const startTransition = qcbYear;
          const endTransition = qcbYear + transitionDur;

          if (year < startTransition) {
              return 0; // No effect yet
          } else if (year >= startTransition && year <= endTransition) {
              const t = (year - startTransition) / transitionDur;
              return t; // Linear transition from 0 to 1
          } else {
              return 1; // Full effect applied
          }
      }
      
      /**
       * Helper function to calculate a single sinusoidal wave's value.
       * This function now calculates the wave's value such that its minimum
       * is directly controlled by `params.yShift` (Offset from Exp Baseline).
       * @param {number} year - The current year.
       * @param {object} params - Object containing parameters for this specific wave.
       * @param {number} startLogYear - The logYear value at the start of the plot (2015).
       * @returns {number} The calculated value for the individual wave (trough controlled).
       */
      function calculateIndividualWaveValue(year, params, startLogYear) {
          let logYear = Math.log10(year - 1969);
          let relativeLogYear = logYear - startLogYear; // Time relative to plot start in log scale

          // Frequency grows multiplicatively with relativeLogYear
          let myFreq = params.freq * (1 + relativeLogYear * params.freqGrowth);
          if (myFreq < 0.0001) myFreq = 0.0001; // Ensure frequency remains positive

          // Amplitude grows multiplicatively (exponentially) with relativeLogYear, now with an additional strength factor
          let myAmp  = params.amp * Math.exp(relativeLogYear * params.ampGrowth * params.ampGrowthStrength); 
          if (myAmp < 0.1) myAmp = 0.1; // Ensure amplitude remains positive

          // NEW: Individual exponential baseline for the wave
          let individualWaveExpBaseline = params.expBase * Math.exp(relativeLogYear * params.expGrowth);
          if (individualWaveExpBaseline <= 0) individualWaveExpBaseline = 0.001; // Ensure positive

          // Pure oscillation of the sine wave
          let pureOscillation = myAmp * Math.sin(2 * Math.PI * myFreq * logYear + params.phase);
          
          // Individual wave value is its oscillation added to its exponential baseline plus a fixed offset
          let individualWaveComponent = individualWaveExpBaseline + pureOscillation + params.yShift; 

          return individualWaveComponent; // Return raw value, will be clamped later for plotting
      }

      /**
       * Helper function to generate combined data for a given set of parameters.
       * This is used by the fitting algorithm to test different parameter combinations
       * without affecting the global state during the optimization process.
       * This function now generates the full combined data without direct power law impact.
       * @param {object} params - An object containing all model parameters.
       * @returns {Array<number>} An array of combined Y-values for the simulated data.
       */
      function generateCombinedData(params) {
          let combinedData = [];
          const startPlotYear = 2015;
          const startLogYear = Math.log10(startPlotYear - 1969);

          // Loop through years from 2015 to 2035 with a step of 0.001 for more data points
          for (let year = 2015; year <= 2035; year = parseFloat((year + 0.001).toFixed(3))) { 
              let logYear = Math.log10(year - 1969);
              // Calculate days since 1970-01-01 for the power law equation - NOT USED FOR COMBINED LINE NOW
              // const daysSince1970 = (year - 1970) * 365.25; 

              let sumOfFullIndividualWaveComponents = 0; // Sum of waves including their individual exponential baselines
              let sumOfPureOscillations = 0; // Sum of just the oscillating parts of the waves

              // Collect parameters for each wave, including the new ampGrowthStrength and expBase/expGrowth
              const waveParams = [
                  { freq: params.wave1Freq, amp: params.wave1Amp, yShift: params.wave1YShift, phase: params.wave1Phase, freqGrowth: params.wave1FreqGrowth, ampGrowth: params.wave1AmpGrowth, ampGrowthStrength: params.wave1AmpGrowthStrength, expBase: params.wave1ExpBase, expGrowth: params.wave1ExpGrowth },
                  { freq: params.wave2Freq, amp: params.wave2Amp, yShift: params.wave2YShift, phase: params.wave2Phase, freqGrowth: params.wave2FreqGrowth, ampGrowth: params.wave2AmpGrowth, ampGrowthStrength: params.wave2AmpGrowthStrength, expBase: params.wave2ExpBase, expGrowth: params.wave2ExpGrowth },
                  { freq: params.wave3Freq, amp: params.wave3Amp, yShift: params.wave3YShift, phase: params.wave3Phase, freqGrowth: params.wave3FreqGrowth, ampGrowth: params.wave3AmpGrowth, ampGrowthStrength: params.wave3AmpGrowthStrength, expBase: params.wave3ExpBase, expGrowth: params.wave3ExpGrowth }
              ];

              for (let i = 0; i < 3; i++) {
                  let currentWave = waveParams[i];
                  let relativeLogYear = logYear - startLogYear; // Time relative to plot start in log scale

                  let myFreq = currentWave.freq * (1 + relativeLogYear * currentWave.freqGrowth);
                  if (myFreq < 0.0001) myFreq = 0.0001; 

                  let myAmp = currentWave.amp * Math.exp(relativeLogYear * currentWave.ampGrowth * currentWave.ampGrowthStrength); 
                  if (myAmp < 0.1) myAmp = 0.1; 

                  // NEW: Individual exponential baseline for the wave
                  let individualWaveExpBaseline = currentWave.expBase * Math.exp(relativeLogYear * currentWave.expGrowth);
                  if (individualWaveExpBaseline <= 0) individualWaveExpBaseline = 0.001;

                  let pureOscillation = myAmp * Math.sin(2 * Math.PI * myFreq * logYear + currentWave.phase);
                  
                  // Individual wave component, including its own exponential baseline and offset
                  let individualWaveComponent = individualWaveExpBaseline + pureOscillation + currentWave.yShift; 
                  sumOfFullIndividualWaveComponents += individualWaveComponent;
                  sumOfPureOscillations += pureOscillation; // Collect pure oscillations (for QCBD effect)
              }

              let finalCombinedValue;

              // Apply QCBD effect ONLY after qcbDateYear - POWER LAW IS NO LONGER INCLUDED HERE
              if (year < params.qcbDateYear) {
                  // Before QCBD: sum of all individual waves, each with its own exponential baseline
                  finalCombinedValue = sumOfFullIndividualWaveComponents;
              } else {
                  const transitionFactor = getQCBDTransitionFactor(year, params.qcbDateYear, params.qcbTransitionDuration);
                  
                  // Value if QCBD has full effect: socialDistrustValue + sumOfPureOscillations
                  // After QCBD, the waves oscillate around socialDistrustValue as a new baseline.
                  let qcbdEffectValue = params.socialDistrustValue + sumOfPureOscillations;

                  // Blend from the pre-QCBD value (sum of full individual waves) to the qcbdEffectValue
                  finalCombinedValue = sumOfFullIndividualWaveComponents * (1 - transitionFactor) + qcbdEffectValue * transitionFactor;
              }
              
              // Ensure the final combined value is always positive for log scale
              combinedData.push(Math.max(0.001, finalCombinedValue));
          }
          return combinedData;
      }

      /**
       * Calculates the Mean Squared Error (MSE) between simulated and actual BTC log prices.
       * This function quantifies how well the simulated curve fits the real data.
       * It compares the logarithm of the simulated values to the logarithm of the BTC values.
       * @param {Array<number>} simulatedData - The Y-values of the simulated combined curve.
       * @param {Array<number>} actualLogPrices - The logarithm of the actual BTC prices.
       * @returns {number} The Mean Squared Error. Returns Infinity if no valid data points for comparison.
       */
      function calculateModelError(simulatedData, actualLogPrices) {
          let error = 0;
          let count = 0;

          const minLen = Math.min(simulatedData.length, actualLogPrices.length);

          for (let i = 0; i < minLen; i++) {
              if (simulatedData[i] > 0) {
                  const logSimulated = Math.log(simulatedData[i]);
                  if (isFinite(actualLogPrices[i])) {
                      error += Math.pow(logSimulated - actualLogPrices[i], 2);
                      count++;
                  }
              }
          }
          return count > 0 ? error / count : Infinity;
      }


      /**
       * Asynchronously fetches Bitcoin (BTCUSDT) weekly closing prices from Binance API.
       * It then creates a Plotly trace for this data, stores it globally, and
       * triggers a full redraw of the graph including the BTC data.
       */
      async function myAddBitcoinToPlot() {
          const url = 'https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1w&limit=1000';
          try {
              document.getElementById('statusMessage').innerText = 'Fetching BTC data...';
              const response = await fetch(url);
              const data = await response.json();

              btcDatesGlobal = data.map(candle => {
                  const d = new Date(candle[0]);
                  return d.getFullYear() + (d.getMonth() / 12); 
              });

              const btcPrices = data.map(candle => parseFloat(candle[4])); 
              btcLogPricesGlobal = btcPrices.map(p => Math.log(p)); 

              btcTraceGlobal = {
                  x: btcDatesGlobal,
                  y: btcPrices,
                  mode: 'lines',
                  line: { color: 'orange', width: 3 },
                  name: 'BTC Price (USD)'
              };

              myGenerateLogLogData();
              document.getElementById('statusMessage').innerText = '✅ Bitcoin data added to plot.';
              console.log('✅ Bitcoin data added to plot.');
          } catch (err) {
              btcTraceGlobal = null; 
              document.getElementById('statusMessage').innerText = '❌ Failed to load BTC data.';
              console.error('❌ Failed to load BTC data:', err);
          }
      }

      /**
       * Attempts to fit the simulated graph to the overlaid BTC data using a simple
       * iterative optimization (random walk / hill climbing).
       * This is a simplified approach and may not find the global optimum.
       */
      async function fitToBTCData() {
          if (btcLogPricesGlobal.length === 0) {
              document.getElementById('statusMessage').innerText = 'Please overlay BTC data first!';
              await myAddBitcoinToPlot(); 
              if (btcLogPricesGlobal.length === 0) {
                  document.getElementById('statusMessage').innerText = 'Failed to get BTC data for fitting.';
                  return; 
              }
          }

          document.getElementById('statusMessage').innerText = 'Fitting model to BTC data... This may take a moment.';
          document.getElementById('fitBtn').disabled = true; 

          let currentBestParams = {
              wave1Freq: wave1Freq, wave1Amp: wave1Amp, wave1YShift: wave1YShift, wave1Phase: wave1Phase, wave1FreqGrowth: wave1FreqGrowth, wave1AmpGrowth: wave1AmpGrowth, wave1AmpGrowthStrength: wave1AmpGrowthStrength, wave1ExpBase: wave1ExpBase, wave1ExpGrowth: wave1ExpGrowth,
              wave2Freq: wave2Freq, wave2Amp: wave2Amp, wave2YShift: wave2YShift, wave2Phase: wave2Phase, wave2FreqGrowth: wave2FreqGrowth, wave2AmpGrowth: wave2AmpGrowth, wave2AmpGrowthStrength: wave2AmpGrowthStrength, wave2ExpBase: wave2ExpBase, wave2ExpGrowth: wave2ExpGrowth,
              wave3Freq: wave3Freq, wave3Amp: wave3Amp, wave3YShift: wave3YShift, wave3Phase: wave3Phase, wave3FreqGrowth: wave3FreqGrowth, wave3AmpGrowth: wave3AmpGrowth, wave3AmpGrowthStrength: wave3AmpGrowthStrength, wave3ExpBase: wave3ExpBase, wave3ExpGrowth: wave3ExpGrowth,
              
              qcbDateYear: qcbDateYear,
              socialDistrustValue: socialDistrustValue, 
              qcbTransitionDuration: qcbTransitionDuration,
              // powerLawConstant and powerLawExponent are NOT fitted as they no longer affect the combined line
          };

          let minError = calculateModelError(generateCombinedData(currentBestParams), btcLogPricesGlobal);

          const numIterations = 50000;
          const learningRate = 0.005;

          console.log('Starting fitting process...');

          for (let iter = 0; iter < numIterations; iter++) {
              let testParams = JSON.parse(JSON.stringify(currentBestParams)); 

              const paramChoices = [
                  { type: 'wave1Freq', scale: 0.005 }, { type: 'wave1Amp', scale: 5 }, { type: 'wave1YShift', scale: 50 }, { type: 'wave1Phase', scale: 0.1 }, { type: 'wave1FreqGrowth', scale: 0.001 }, { type: 'wave1AmpGrowth', scale: 0.01 }, { type: 'wave1AmpGrowthStrength', scale: 0.1 }, { type: 'wave1ExpBase', scale: 10 }, { type: 'wave1ExpGrowth', scale: 0.01 },
                  { type: 'wave2Freq', scale: 0.005 }, { type: 'wave2Amp', scale: 5 }, { type: 'wave2YShift', scale: 50 }, { type: 'wave2Phase', scale: 0.1 }, { type: 'wave2FreqGrowth', scale: 0.001 }, { type: 'wave2AmpGrowth', scale: 0.01 }, { type: 'wave2AmpGrowthStrength', scale: 0.1 }, { type: 'wave2ExpBase', scale: 10 }, { type: 'wave2ExpGrowth', scale: 0.01 },
                  { type: 'wave3Freq', scale: 0.005 }, { type: 'wave3Amp', scale: 5 }, { type: 'wave3YShift', scale: 50 }, { type: 'wave3Phase', scale: 0.1 }, { type: 'wave3FreqGrowth', scale: 0.001 }, { type: 'wave3AmpGrowth', scale: 0.01 }, { type: 'wave3AmpGrowthStrength', scale: 0.1 }, { type: 'wave3ExpBase', scale: 10 }, { type: 'wave3ExpGrowth', scale: 0.01 },
                  
                  { type: 'qcbDateYear', scale: 0.1 },
                  { type: 'socialDistrustValue', scale: 50 }, 
                  { type: 'qcbTransitionDuration', scale: 0.05 },
              ];
              const chosenParam = paramChoices[Math.floor(Math.random() * paramChoices.length)];
              const perturbation = (Math.random() * 2 - 1) * chosenParam.scale * learningRate;

              testParams[chosenParam.type] += perturbation;

              // --- START: Robust parameter clamping ---
              switch (chosenParam.type) {
                  case 'wave1Freq': case 'wave2Freq': case 'wave3Freq':
                      testParams[chosenParam.type] = Math.max(0.0001, testParams[chosenParam.type]);
                      break;
                  case 'wave1Amp': case 'wave2Amp': case 'wave3Amp':
                      testParams[chosenParam.type] = Math.max(0.1, testParams[chosenParam.type]);
                      break;
                  // YShift (offset) can be negative or positive
                  case 'wave1YShift': case 'wave2YShift': case 'wave3YShift':
                      // No specific clamping for min/max, let optimizer explore. Can be 0 or negative/positive.
                      break;
                  case 'wave1AmpGrowth': case 'wave2AmpGrowth': case 'wave3AmpGrowth':
                      testParams[chosenParam.type] = Math.max(0.0, testParams[chosenParam.type]); 
                      break;
                  case 'wave1AmpGrowthStrength': case 'wave2AmpGrowthStrength': case 'wave3AmpGrowthStrength':
                      testParams[chosenParam.type] = Math.max(0.1, testParams[chosenParam.type]); 
                      break;
                  case 'wave1ExpBase': case 'wave2ExpBase': case 'wave3ExpBase':
                      testParams[chosenParam.type] = Math.max(0.001, testParams[chosenParam.type]); // Exponential base must be positive
                      break;
                  case 'wave1ExpGrowth': case 'wave2ExpGrowth': case 'wave3ExpGrowth':
                      testParams[chosenParam.type] = Math.min(Math.max(testParams[chosenParam.type], -0.5), 0.5); // Allow negative growth for exp, but clamp
                      break;
                  case 'qcbDateYear':
                      testParams[chosenParam.type] = Math.min(Math.max(testParams[chosenParam.type], 2025), 2040); 
                      break;
                  case 'socialDistrustValue': 
                      testParams[chosenParam.type] = Math.max(testParams[chosenParam.type], 0.001); 
                      break;
                  case 'qcbTransitionDuration':
                      testParams[chosenParam.type] = Math.min(Math.max(testParams[chosenParam.type], 0.1), 5.0); 
                      break;
                  // Removed powerLawConstant and powerLawExponent from clamping as they are not fitted
                  default:
                      if (!Number.isFinite(testParams[chosenParam.type])) {
                          testParams[chosenParam.type] = 0;
                      }
                      break;
              }
              // --- END: Robust parameter clamping ---

              const newSimulatedData = generateCombinedData(testParams);
              const currentError = calculateModelError(newSimulatedData, btcLogPricesGlobal);

              if (currentError < minError) {
                  minError = currentError;
                  currentBestParams = testParams;
                  if (iter % 1000 === 0) {
                      console.log(`Iteration ${iter}: New best error = ${minError.toFixed(6)}`);
                  }
              }
              if (iter % 500 === 0) {
                  document.getElementById('statusMessage').innerText = `Fitting... Iteration ${iter}/${numIterations}. Current best error: ${minError.toFixed(6)}`;
                  await new Promise(resolve => setTimeout(resolve, 0));
              }
          }

          // Apply the best found parameters globally and update input fields
          const updateInputField = (id, value) => {
              const element = document.getElementById(id);
              if (element) {
                  if (Number.isFinite(value)) {
                      // Power law constants should still be formatted as exponential if they were fitted
                      // But since they are not fitted, this part of the logic is less critical for them.
                      // For general inputs, toFixed(3) is usually fine.
                      element.value = value.toFixed(3);
                  } else {
                      element.value = '0.000'; 
                      console.warn(`Parameter ${id} was not finite (${value}). Setting to 0.000.`);
                  }
              }
          };

          wave1Freq = currentBestParams.wave1Freq; updateInputField('wave1FreqInput', wave1Freq);
          wave1Amp = currentBestParams.wave1Amp; updateInputField('wave1AmpInput', wave1Amp);
          wave1YShift = currentBestParams.wave1YShift; updateInputField('wave1YShiftInput', wave1YShift);
          wave1Phase = currentBestParams.wave1Phase; updateInputField('wave1PhaseInput', wave1Phase);
          wave1FreqGrowth = currentBestParams.wave1FreqGrowth; updateInputField('wave1FreqGrowthInput', wave1FreqGrowth);
          wave1AmpGrowth = currentBestParams.wave1AmpGrowth; updateInputField('wave1AmpGrowthInput', wave1AmpGrowth);
          wave1AmpGrowthStrength = currentBestParams.wave1AmpGrowthStrength; updateInputField('wave1AmpGrowthStrengthInput', wave1AmpGrowthStrength);
          wave1ExpBase = currentBestParams.wave1ExpBase; updateInputField('wave1ExpBaseInput', wave1ExpBase);
          wave1ExpGrowth = currentBestParams.wave1ExpGrowth; updateInputField('wave1ExpGrowthInput', wave1ExpGrowth);

          wave2Freq = currentBestParams.wave2Freq; updateInputField('wave2FreqInput', wave2Freq);
          wave2Amp = currentBestParams.wave2Amp; updateInputField('wave2AmpInput', wave2Amp);
          wave2YShift = currentBestParams.wave2YShift; updateInputField('wave2YShiftInput', wave2YShift);
          wave2Phase = currentBestParams.wave2Phase; updateInputField('wave2PhaseInput', wave2Phase);
          wave2FreqGrowth = currentBestParams.wave2FreqGrowth; updateInputField('wave2FreqGrowthInput', wave2FreqGrowth);
          wave2AmpGrowth = currentBestParams.wave2AmpGrowth; updateInputField('wave2AmpGrowthInput', wave2AmpGrowth);
          wave2AmpGrowthStrength = currentBestParams.wave2AmpGrowthStrength; updateInputField('wave2AmpGrowthStrengthInput', wave2AmpGrowthStrength);
          wave2ExpBase = currentBestParams.wave2ExpBase; updateInputField('wave2ExpBaseInput', wave2ExpBase);
          wave2ExpGrowth = currentBestParams.wave2ExpGrowth; updateInputField('wave2ExpGrowthInput', wave2ExpGrowth);

          wave3Freq = currentBestParams.wave3Freq; updateInputField('wave3FreqInput', wave3Freq);
          wave3Amp = currentBestParams.wave3Amp; updateInputField('wave3AmpInput', wave3Amp);
          wave3YShift = currentBestParams.wave3YShift; updateInputField('wave3YShiftInput', wave3YShift);
          wave3Phase = currentBestParams.wave3Phase; updateInputField('wave3PhaseInput', wave3Phase);
          wave3FreqGrowth = currentBestParams.wave3FreqGrowth; updateInputField('wave3FreqGrowthInput', wave3FreqGrowth);
          wave3AmpGrowth = currentBestParams.wave3AmpGrowth; updateInputField('wave3AmpGrowthInput', wave3AmpGrowth);
          wave3AmpGrowthStrength = currentBestParams.wave3AmpGrowthStrength; updateInputField('wave3AmpGrowthStrengthInput', wave3AmpGrowthStrength);
          wave3ExpBase = currentBestParams.wave3ExpBase; updateInputField('wave3ExpBaseInput', wave3ExpBase);
          wave3ExpGrowth = currentBestParams.wave3ExpGrowth; updateInputField('wave3ExpGrowthInput', wave3ExpGrowth);

          qcbDateYear = currentBestParams.qcbDateYear; updateInputField('qcbDateInput', qcbDateYear);
          socialDistrustValue = currentBestParams.socialDistrustValue; updateInputField('socialDistrustValueInput', socialDistrustValue); 
          qcbTransitionDuration = currentBestParams.qcbTransitionDuration; updateInputField('qcbTransitionInput', qcbTransitionDuration);
          // powerLawConstant and powerLawExponent inputs are not updated by fitting
          // updateInputField('powerLawConstantInput', powerLawConstant); // Keep original formatting
          // updateInputField('powerLawExponentInput', powerLawExponent); 

          document.getElementById('statusMessage').innerText = `Fitting complete. Best error: ${minError.toFixed(6)}`;
          document.getElementById('fitBtn').disabled = false;
          console.log(`Fitting complete. Best error: ${minError.toFixed(6)}`);
          console.log('New optimized parameters:', currentBestParams);
          myGenerateLogLogData();
      }


      /**
       * Generates and plots sinusoidal growth data on a log-log scale.
       * The function calculates three individual waves and a combined sum,
       * applying exponential growth to both amplitude and frequency,
       * and an exponential baseline with a constant offset.
       * This function now also includes the global BTC trace if it exists.
       */
      function myGenerateLogLogData() {
        let myYears = [];
        let myCombined = []; 
        let myWaves = [[], [], []];
        let qcbCrashLineData = []; // Renamed for clarity
        let independentPowerLawData = []; // New array for independent power law

        const startPlotYear = 2015;
        const startLogYear = Math.log10(startPlotYear - 1969);

        const waveParameters = [
            { freq: wave1Freq, amp: wave1Amp, yShift: wave1YShift, phase: wave1Phase, freqGrowth: wave1FreqGrowth, ampGrowth: wave1AmpGrowth, ampGrowthStrength: wave1AmpGrowthStrength, expBase: wave1ExpBase, expGrowth: wave1ExpGrowth },
            { freq: wave2Freq, amp: wave2Amp, yShift: wave2YShift, phase: wave2Phase, freqGrowth: wave2FreqGrowth, ampGrowth: wave2AmpGrowth, ampGrowthStrength: wave2AmpGrowthStrength, expBase: wave2ExpBase, expGrowth: wave2ExpGrowth },
            { freq: wave3Freq, amp: wave3Amp, yShift: wave3YShift, phase: wave3Phase, freqGrowth: wave3FreqGrowth, ampGrowth: wave3AmpGrowth, ampGrowthStrength: wave3AmpGrowthStrength, expBase: wave3ExpBase, expGrowth: wave3ExpGrowth }
        ];

        for (let year = 2015; year <= 2035; year = parseFloat((year + 0.001).toFixed(3))) { 
          let logYear = Math.log10(year - 1969);
          myYears.push(year);
          let relativeLogYear = logYear - startLogYear; 
          
          const daysSince1970 = (year - 1970) * 365.25;

          let sumOfFullIndividualWaveComponents = 0; 
          let sumOfPureOscillations = 0; 

          for (let i = 0; i < 3; i++) {
            let currentWave = waveParameters[i];
            let myFreq = currentWave.freq * (1 + relativeLogYear * currentWave.freqGrowth);
            if (myFreq < 0.0001) myFreq = 0.0001; 

            let myAmp = currentWave.amp * Math.exp(relativeLogYear * currentWave.ampGrowth * currentWave.ampGrowthStrength); 
            if (myAmp < 0.1) myAmp = 0.1; 

            // NEW: Individual exponential baseline for the wave
            let individualWaveExpBaseline = currentWave.expBase * Math.exp(relativeLogYear * currentWave.expGrowth);
            if (individualWaveExpBaseline <= 0) individualWaveExpBaseline = 0.001;

            let pureOscillation = myAmp * Math.sin(2 * Math.PI * myFreq * logYear + currentWave.phase);
            
            let individualWaveComponent = individualWaveExpBaseline + pureOscillation + currentWave.yShift; 
            sumOfFullIndividualWaveComponents += individualWaveComponent;
            sumOfPureOscillations += pureOscillation; 

            myWaves[i].push(Math.max(0.001, individualWaveComponent)); 
          }

          // Calculate the INDEPENDENT Power Law trace value (green line)
          let currentPowerLawValue = powerLawConstant * Math.pow(daysSince1970, powerLawExponent);
          if (currentPowerLawValue <= 0) currentPowerLawValue = 0.001;
          if (currentPowerLawValue > 1e10) currentPowerLawValue = 1e10; // Cap for visibility
          independentPowerLawData.push(currentPowerLawValue);

          // Calculate the QCBD Crash Line value (red dashed trace)
          const qcbLineValueForPlot = getQCBDCrashLineValue(year, qcbDateYear, socialDistrustValue, qcbTransitionDuration);
          qcbCrashLineData.push(qcbLineValueForPlot); 

          let finalCombinedValue;

          if (year < qcbDateYear) {
              finalCombinedValue = sumOfFullIndividualWaveComponents;
          } else {
              const transitionFactor = getQCBDTransitionFactor(year, qcbDateYear, qcbTransitionDuration);
              
              // QCBD effect value for the combined line: socialDistrustValue + sumOfPureOscillations
              // The power law is NOT included here, it's plotted separately.
              let qcbdEffectValue = socialDistrustValue + sumOfPureOscillations; 

              // Blend from the pre-QCBD value (sum of full individual waves) to the qcbdEffectValue
              finalCombinedValue = sumOfFullIndividualWaveComponents * (1 - transitionFactor) + qcbdEffectValue * transitionFactor;
          }
          
          myCombined.push(Math.max(0.001, finalCombinedValue));
        }

        // Plot individual sine wave components
        let myTraces = myWaves.map((wave, i) => ({
          x: myYears,
          y: wave,
          mode: 'lines',
          line: { color: 'green', width: 1 }, // Changed to dot for clarity, can be solid green too
          name: 'Wave ' + (i + 1)
        }));

        // Add the combined wave (sum of all individual waves and the QCBD impact)
        myTraces.push({
          x: myYears,
          y: myCombined,
          mode: 'lines',
          line: { color: 'blue', width: 3 },
          name: 'Combined'
        });

        // Add the Independent Power Law trace (new, green solid line)
        myTraces.push({
            x: myYears,
            y: independentPowerLawData,
            mode: 'lines',
            line: { color: 'yellow', width: 3, dash: 'solid' }, // Solid green
            name: 'Independent Power Law'
        });

        // Add the QCBD Crash Line trace (red dashed)
        myTraces.push({
            x: myYears, 
            y: qcbCrashLineData,
            mode: 'lines',
            line: { color: 'red', width: 3, dash: 'dashdot' }, 
            name: 'QCBD Crash Line'
        });

        if (btcTraceGlobal) {
            const filteredBtcX = [];
            const filteredBtcY = [];
            const startPlotYear = 2015; 
            for (let i = 0; i < btcDatesGlobal.length; i++) {
                if (btcDatesGlobal[i] >= startPlotYear && btcDatesGlobal[i] <= 2035) {
                    filteredBtcX.push(btcDatesGlobal[i]);
                    filteredBtcY.push(btcTraceGlobal.y[i]);
                }
            }
            myTraces.push({
                x: filteredBtcX,
                y: filteredBtcY,
                mode: 'lines',
                line: { color: 'orange', width: 3 },
                name: 'BTC Price (USD)'
            });
        }

        let myLayout = {
          title: 'Vibe Coding BTC Sinusoids',
          xaxis: {
            title: 'Year',
            type: 'log',
            tickangle: -45,
            range: [Math.log10(startPlotYear), Math.log10(2035)], 
            tickvals: [2015, 2020, 2025, 2030, 2035], 
            ticktext: ['2015', '2020', '2025', '2030', '2035'] 
          },
          yaxis: {
            title: 'Simulated Dollars',
            type: 'log',
            range: [0, 7] 
          },
          margin: { t: 40 }
        };

        Plotly.newPlot('myPlot', myTraces, myLayout);
      }


      /**
       * Performs a simple linear regression to find slope and intercept.
       * @param {Array<number>} xData - Array of x values.
       * @param {Array<number>} yData - Array of y values.
       * @returns {{slope: number, intercept: number}} The calculated slope and intercept.
       */
      function linearRegression(xData, yData) {
          let N = xData.length;
          let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;

          for (let i = 0; i < N; i++) {
              sumX += xData[i];
              sumY += yData[i];
              sumXY += xData[i] * yData[i];
              sumXX += xData[i] * xData[i];
          }

          let slope = (N * sumXY - sumX * sumY) / (N * sumXX - sumX * sumX);
          let intercept = (sumY - slope * sumX) / N;

          return { slope, intercept };
      }
      
      /**
       * Updates sinusoidal parameters (freq, phase) using a spectral analysis
       * (correlation-based frequency detection) on detrended BTC log data.
       * This serves as an initial guess for the optimizer for the wave components.
       * Global baseline parameters are NOT set by this function.
       */
      async function updateSinusoidsWithFFTAnalysis() {
          if (btcLogPricesGlobal.length === 0 || btcDatesGlobal.length === 0) {
              document.getElementById('statusMessage').innerText = 'Please load BTC data first!';
              await myAddBitcoinToPlot(); 
              if (btcLogPricesGlobal.length === 0) {
                  document.getElementById('statusMessage').innerText = 'Failed to get BTC data for FFT analysis.';
                  return;
              }
          }

          document.getElementById('statusMessage').innerText = 'Performing FFT analysis...';
          document.getElementById('fftBtn').disabled = true;

          console.log("Initializing wave parameters with spectral analysis...");

          const btcLogYears = btcDatesGlobal.map(year => Math.log10(year - 1969));

          const { slope: tempTrendSlope, intercept: tempTrendIntercept } = linearRegression(btcLogYears, btcLogPricesGlobal);
          const detrendedLogPrices = btcLogPricesGlobal.map((logPrice, i) => logPrice - (tempTrendSlope * btcLogYears[i] + tempTrendIntercept));

          const spectralResults = [];
          const minFreq = 0.001; 
          const maxFreq = 0.5;   
          const freqStep = 0.0005; 

          for (let freq = minFreq; freq <= maxFreq; freq += freqStep) {
              let sumSin = 0;
              let sumCos = 0;
              let N = detrendedLogPrices.length;

              for (let i = 0; i < N; i++) {
                  const angle = 2 * Math.PI * freq * btcLogYears[i];
                  sumSin += detrendedLogPrices[i] * Math.sin(angle);
                  sumCos += detrendedLogPrices[i] * Math.cos(angle);
              }

              const amp = Math.sqrt(sumSin * sumSin + sumCos * sumCos) / N * 2; 
              const phase = Math.atan2(sumCos, sumSin); 

              spectralResults.push({ freq: freq, amp: amp, phase: phase });
          }

          spectralResults.sort((a, b) => b.amp - a.amp); 

          const selectedWaves = [];
          const minFreqSeparation = 0.02; 

          for (const result of spectralResults) {
              if (selectedWaves.length >= 3) break; 

              let isDistinct = true;
              for (const existingWave of selectedWaves) {
                  if (Math.abs(result.freq - existingWave.freq) < minFreqSeparation ||
                      (existingWave.freq > 0 && Math.abs(result.freq / existingWave.freq - Math.round(result.freq / existingWave.freq)) < 0.05) ||
                      (result.freq > 0 && Math.abs(existingWave.freq / result.freq - Math.round(existingWave.freq / result.freq)) < 0.05)
                  ) {
                      isDistinct = false;
                      break;
                  }
              }

              if (isDistinct) {
                  selectedWaves.push(result);
              }
          }
          
          while (selectedWaves.length < 3) {
              selectedWaves.push({ freq: 0.01 + selectedWaves.length * 0.02, amp: 0, phase: 0 }); 
          }

          wave1Freq = selectedWaves[0].freq;
          wave1Phase = selectedWaves[0].phase;

          wave2Freq = selectedWaves[1].freq;
          wave2Phase = selectedWaves[1].phase;

          wave3Freq = selectedWaves[2].freq;
          wave3Phase = selectedWaves[2].phase;

          document.getElementById('wave1FreqInput').value = wave1Freq.toFixed(3);
          document.getElementById('wave1PhaseInput').value = wave1Phase.toFixed(3);

          document.getElementById('wave2FreqInput').value = wave2Freq.toFixed(3);
          document.getElementById('wave2PhaseInput').value = wave2Phase.toFixed(3);

          document.getElementById('wave3FreqInput').value = wave3Freq.toFixed(3);
          document.getElementById('wave3PhaseInput').value = wave3Phase.toFixed(3);

          console.log("Wave parameter initialization complete via spectral analysis.", {
              wave1: { freq: wave1Freq, phase: wave1Phase },
              wave2: { freq: wave2Freq, phase: wave2Phase },
              wave3: { freq: wave3Freq, phase: wave3Phase }
          });

          myGenerateLogLogData(); 
          document.getElementById('statusMessage').innerText = 'FFT analysis complete. Wave frequencies and phases updated.';
          document.getElementById('fftBtn').disabled = false;
      }

      /**
       * Initializes the input fields with the current global variable values.
       * This function is called once on page load to ensure UI consistency.
       */
      function initializeInputFields() {
          document.getElementById('qcbDateInput').value = qcbDateYear.toFixed(3);
          document.getElementById('socialDistrustValueInput').value = socialDistrustValue.toFixed(3);
          document.getElementById('qcbTransitionInput').value = qcbTransitionDuration.toFixed(3);
          document.getElementById('powerLawConstantInput').value = powerLawConstant.toExponential(3); 
          document.getElementById('powerLawExponentInput').value = powerLawExponent.toFixed(3);

          document.getElementById('wave1FreqInput').value = wave1Freq.toFixed(3);
          document.getElementById('wave1AmpInput').value = wave1Amp.toFixed(3);
          document.getElementById('wave1YShiftInput').value = wave1YShift.toFixed(3);
          document.getElementById('wave1PhaseInput').value = wave1Phase.toFixed(3);
          document.getElementById('wave1FreqGrowthInput').value = wave1FreqGrowth.toFixed(3);
          document.getElementById('wave1AmpGrowthInput').value = wave1AmpGrowth.toFixed(3);
          document.getElementById('wave1AmpGrowthStrengthInput').value = wave1AmpGrowthStrength.toFixed(3);
          document.getElementById('wave1ExpBaseInput').value = wave1ExpBase.toFixed(3);
          document.getElementById('wave1ExpGrowthInput').value = wave1ExpGrowth.toFixed(3);

          document.getElementById('wave2FreqInput').value = wave2Freq.toFixed(3);
          document.getElementById('wave2AmpInput').value = wave2Amp.toFixed(3);
          document.getElementById('wave2YShiftInput').value = wave2YShift.toFixed(3);
          document.getElementById('wave2PhaseInput').value = wave2Phase.toFixed(3);
          document.getElementById('wave2FreqGrowthInput').value = wave2FreqGrowth.toFixed(3);
          document.getElementById('wave2AmpGrowthInput').value = wave2AmpGrowth.toFixed(3);
          document.getElementById('wave2AmpGrowthStrengthInput').value = wave2AmpGrowthStrength.toFixed(3);
          document.getElementById('wave2ExpBaseInput').value = wave2ExpBase.toFixed(3);
          document.getElementById('wave2ExpGrowthInput').value = wave2ExpGrowth.toFixed(3);

          document.getElementById('wave3FreqInput').value = wave3Freq.toFixed(3);
          document.getElementById('wave3AmpInput').value = wave3Amp.toFixed(3);
          document.getElementById('wave3YShiftInput').value = wave3YShift.toFixed(3);
          document.getElementById('wave3PhaseInput').value = wave3Phase.toFixed(3);
          document.getElementById('wave3FreqGrowthInput').value = wave3FreqGrowth.toFixed(3);
          document.getElementById('wave3AmpGrowthInput').value = wave3AmpGrowth.toFixed(3);
          document.getElementById('wave3AmpGrowthStrengthInput').value = wave3AmpGrowthStrength.toFixed(3);
          document.getElementById('wave3ExpBaseInput').value = wave3ExpBase.toFixed(3);
          document.getElementById('wave3ExpGrowthInput').value = wave3ExpGrowth.toFixed(3);
      }


      myGenerateLogLogData();
      myAddBitcoinToPlot();
      initializeInputFields();
    </script>
  </body>
</html>
