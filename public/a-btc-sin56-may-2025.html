<!DOCTYPE html>
<html>
  <head>
    <title>Vibe Coding BTC Sinusoids</title>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <style>
      /* Absolute minimum CSS in style block */
      body {
        font-family: sans-serif;
        margin: 20px;
      }
    </style>
  </head>
  <body>
    <div style="max-width: 1200px; margin: 0 auto; padding: 0 10px;">
      <div style="margin-bottom: 20px;">
        <h2 style="font-size: 2em; margin-bottom: 15px; text-align: center;">Vibe Coding BTC Sinusoids</h2>
        <p style="margin-bottom: 10px;">The <a href="https://charts.bitbo.io/long-term-power-law/">power-law BTC equation</a> plotting BTC on a price-date log-log graph with max-min parameters. This is interesting, but anyone should be able to see the complex sinusoidal potential in that graph. This page is my attempt to give people their own control of this complexity.</p>



        <div style="display: flex; justify-content: center; flex-wrap: wrap; gap: 20px; margin-bottom: 15px;">
          <div style="border: 1px solid #ddd; padding: 15px; background-color: #f9f9f9; border-radius: 5px; flex: 1 1 450px; max-width: 550px;">
            <h3 style="font-size: 1.3em; margin-top: 0; margin-bottom: 10px; border-bottom: 1px solid #eee; padding-bottom: 5px;">QCBD Parameters <small>(Quantum Crypto Breaking Date)</small></h3>
            <div style="margin-bottom: 10px;">
              <label for="qcbDateInput" style="display: block; margin-bottom: 2px; font-weight: bold;">QCBD Year:</label>
              <input type="text" id="qcbDateInput" value="2030.0" size="8" onchange="qcbDateYear = parseFloat(this.value); myGenerateLogLogData();" style="width: calc(100% - 10px); padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 10px;">
              <label for="socialDistrustValueInput" style="display: block; margin-bottom: 2px; font-weight: bold;">Social Distrust (Crash Target): <small>(Set low for dramatic crash)</small></label>
              <input type="text" id="socialDistrustValueInput" value="500" size="10" onchange="socialDistrustValue = parseFloat(this.value); myGenerateLogLogData();" style="width: calc(100% - 10px); padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 10px;">
              <label for="qcbTransitionInput" style="display: block; margin-bottom: 2px; font-weight: bold;">QCBD Transition (Years):</label>
              <input type="text" id="qcbTransitionInput" value="0.5" size="6" onchange="qcbTransitionDuration = parseFloat(this.value); myGenerateLogLogData();" style="width: calc(100% - 10px); padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 10px;">
              <label for="qcbCrashStrengthInput" style="display: block; margin-bottom: 2px; font-weight: bold;">QCBD Crash Strength: <small>(Higher = faster drop)</small></label>
              <input type="text" id="qcbCrashStrengthInput" value="5.0" size="6" onchange="qcbCrashStrength = parseFloat(this.value); myGenerateLogLogData();" style="width: calc(100% - 10px); padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 10px;">
              <label for="qcbAmplitudeDampeningInput" style="display: block; margin-bottom: 2px; font-weight: bold;">QCBD Amplitude Dampening: <small>(0.0 = flat, 1.0 = no dampening)</small></label>
              <input type="text" id="qcbAmplitudeDampeningInput" value="0.005" size="6" onchange="qcbAmplitudeDampening = parseFloat(this.value); myGenerateLogLogData();" style="width: calc(100% - 10px); padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
            </div>
          </div>

          <div style="border: 1px solid #ddd; padding: 15px; background-color: #f9f9f9; border-radius: 5px; flex: 1 1 450px; max-width: 550px;">
            <h3 style="font-size: 1.3em; margin-top: 0; margin-bottom: 10px; border-bottom: 1px solid #eee; padding-bottom: 5px;">Independent Power Law Parameters <small>(Not Affecting Combined Line)</small></h3>
            <p style="font-size: 0.9em; color: #777; margin-bottom: 10px;">These lines are for visual comparison and are separate from the combined sinusoidal model.</p>


            
            <h4 style="font-size: 1.1em; margin-top: 15px; margin-bottom: 10px;">Max Independent Power Law</h4>
            <div style="margin-bottom: 10px;">
              <label for="independentPowerLawAmplitudeMaxInput" style="display: block; margin-bottom: 2px; font-weight: bold;">Amplitude (Max):</label>
              <input type="text" id="independentPowerLawAmplitudeMaxInput" value="1.0e-16" size="15" onchange="independentPowerLawAmplitudeMax = parseFloat(this.value); myGenerateLogLogData();" style="width: calc(100% - 10px); padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 10px;">
              <label for="independentPowerLawExponentMaxInput" style="display: block; margin-bottom: 2px; font-weight: bold;">Exponent (Max):</label>
              <input type="text" id="independentPowerLawExponentMaxInput" value="5.85" size="10" onchange="independentPowerLawExponentMax = parseFloat(this.value); myGenerateLogLogData();" style="width: calc(100% - 10px); padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
            </div>

            
            <h4 style="font-size: 1.1em; margin-top: 15px; margin-bottom: 10px;">Expected BTC</h4>
            <div style="margin-bottom: 10px;">
              <label for="independentPowerLawAmplitudeInput" style="display: block; margin-bottom: 2px; font-weight: bold;">Amplitude:</label>
              <input type="text" id="independentPowerLawAmplitudeInput" value="1.0e-17" size="15" onchange="independentPowerLawAmplitude = parseFloat(this.value); myGenerateLogLogData();" style="width: calc(100% - 10px); padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 10px;">
              <label for="independentPowerLawExponentInput" style="display: block; margin-bottom: 2px; font-weight: bold;">Exponent:</label>
              <input type="text" id="independentPowerLawExponentInput" value="5.8" size="10" onchange="independentPowerLawExponent = parseFloat(this.value); myGenerateLogLogData();" style="width: calc(100% - 10px); padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
            </div>


            <h4 style="font-size: 1.1em; margin-top: 15px; margin-bottom: 10px;">Min Independent Power Law</h4>
            <div style="margin-bottom: 10px;">
              <label for="independentPowerLawAmplitudeMinInput" style="display: block; margin-bottom: 2px; font-weight: bold;">Amplitude (Min):</label>
              <input type="text" id="independentPowerLawAmplitudeMinInput" value="1.0e-18" size="15" onchange="independentPowerLawAmplitudeMin = parseFloat(this.value); myGenerateLogLogData();" style="width: calc(100% - 10px); padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 10px;">
              <label for="independentPowerLawExponentMinInput" style="display: block; margin-bottom: 2px; font-weight: bold;">Exponent (Min):</label>
              <input type="text" id="independentPowerLawExponentMinInput" value="5.75" size="10" onchange="independentPowerLawExponentMin = parseFloat(this.value); myGenerateLogLogData();" style="width: calc(100% - 10px); padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
            </div>
          </div>
        </div>

        <div style="display: flex; justify-content: center; flex-wrap: wrap;">
          <div style="border: 1px solid #ddd; padding: 15px; margin: 10px; background-color: #f9f9f9; border-radius: 5px;">
            <h4 style="font-size: 1.1em; margin-top: 0; margin-bottom: 10px;">Wave 1</h4>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Frequency:</label><input type="text" value="7" size="6" id="wave1FreqInput" onchange="wave1Freq = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Amplitude (Multiplicative Factor):</label><input type="text" value="10000" size="6" id="wave1AmpInput" onchange="wave1Amp = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Phase (radians):</label><input type="text" value="0.0" size="6" id="wave1PhaseInput" onchange="wave1Phase = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Freq Growth Factor:</label><input type="text" value="0.0" size="6" id="wave1FreqGrowthInput" onchange="wave1FreqGrowth = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Amp Growth Factor:</label><input type="text" value="0.1" size="6" id="wave1AmpGrowthInput" onchange="wave1AmpGrowth = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Amp Growth Strength:</label><input type="text" value="1.0" size="6" id="wave1AmpGrowthStrengthInput" onchange="wave1AmpGrowthStrength = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <hr style="margin: 10px 0;">
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">PL Amplitude:</label><input type="text" value="1.0e-17" size="10" id="wave1PowerLawAmplitudeInput" onchange="wave1PowerLawAmplitude = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">PL Exponent:</label><input type="text" value="5.85" size="10" id="wave1PowerLawExponentInput" onchange="wave1PowerLawExponent = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
          </div>

          <div style="border: 1px solid #ddd; padding: 15px; margin: 10px; background-color: #f9f9f9; border-radius: 5px;">
            <h4 style="font-size: 1.1em; margin-top: 0; margin-bottom: 10px;">Wave 2</h4>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Frequency:</label><input type="text" value="77" size="6" id="wave2FreqInput" onchange="wave2Freq = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Amplitude (Multiplicative Factor):</label><input type="text" value="5000" size="6" id="wave2AmpInput" onchange="wave2Amp = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Phase (radians):</label><input type="text" value="0.0" size="6" id="wave2PhaseInput" onchange="wave2Phase = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Freq Growth Factor:</label><input type="text" value="0.0" size="6" id="wave2FreqGrowthInput" onchange="wave2FreqGrowth = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Amp Growth Factor:</label><input type="text" value="0.1" size="6" id="wave2AmpGrowthInput" onchange="wave2AmpGrowth = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Amp Growth Strength:</label><input type="text" value="1.0" size="6" id="wave2AmpGrowthStrengthInput" onchange="wave2AmpGrowthStrength = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <hr style="margin: 10px 0;">
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">PL Amplitude:</label><input type="text" value="1.0e-17" size="10" id="wave2PowerLawAmplitudeInput" onchange="wave2PowerLawAmplitude = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">PL Exponent:</label><input type="text" value="5.85" size="10" id="wave2PowerLawExponentInput" onchange="wave2PowerLawExponent = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
          </div>

          <div style="border: 1px solid #ddd; padding: 15px; margin: 10px; background-color: #f9f9f9; border-radius: 5px;">
            <h4 style="font-size: 1.1em; margin-top: 0; margin-bottom: 10px;">Wave 3</h4>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Frequency:</label><input type="text" value="777" size="6" id="wave3FreqInput" onchange="wave3Freq = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Amplitude (Multiplicative Factor):</label><input type="text" value="5000" size="6" id="wave3AmpInput" onchange="wave3Amp = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Phase (radians):</label><input type="text" value="0.0" size="6" id="wave3PhaseInput" onchange="wave3Phase = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Freq Growth Factor:</label><input type="text" value="0.0" size="6" id="wave3FreqGrowthInput" onchange="wave3FreqGrowth = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Amp Growth Factor:</label><input type="text" value="0.1" size="6" id="wave3AmpGrowthInput" onchange="wave3AmpGrowth = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">Amp Growth Strength:</label><input type="text" value="1.0" size="6" id="wave3AmpGrowthStrengthInput" onchange="wave3AmpGrowthStrength = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <hr style="margin: 10px 0;">
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">PL Amplitude:</label><input type="text" value="1.0e-17" size="10" id="wave3PowerLawAmplitudeInput" onchange="wave3PowerLawAmplitude = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
            <div style="margin-bottom: 10px;"><label style="display: inline-block; width: 120px; text-align: right; margin-right: 5px;">PL Exponent:</label><input type="text" value="5.85" size="10" id="wave3PowerLawExponentInput" onchange="wave3PowerLawExponent = parseFloat(this.value); myGenerateLogLogData();" style="margin-bottom: 5px;"></div>
          </div>
        </div>
      </div>

              <div style="margin-top: 20px; display: flex; flex-direction: column; gap: 10px;">
            <!-- New Optimize Button -->
            <button onclick="optimizeModel(1)" >Optimize Combined Line to BTC</button>
           <input type=number value = 1 id="myNumIn" size=7   onChange="{

             console.log(`Optimize this many times ${this.value}`)
               myOpto(this.value)
           }">
              
          </div>


        <div id="statusMessage" style="margin-top: 10px; padding: 10px; background-color: #e0f7fa; border: 1px solid #b2ebf2; border-radius: 5px; color: #00796b; font-size: 0.9em;">Status: Ready</div>
         <br>  
      <div style="width: 100%; height: 80vh; border: 1px solid #ccc; box-shadow: 2px 2px 5px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: center;">
        <div id="myPlot" style="width:100%; height:100%;"></div>
      </div>
    </div>

    <script>
      // Function to calculate days since January 3, 2009 (Bitcoin Genesis Block)
      function daysSinceGenesis(date) {
          const genesisDate = new Date('2009-01-03T00:00:00Z');
          const diffTime = Math.abs(date.getTime() - genesisDate.getTime());
          return Math.ceil(diffTime / (1000 * 60 * 60 * 24)); // Convert milliseconds to days
      }

      // --- NEW CORE FUNCTIONS FOR MULTIPLICATIVE WAVES ---

      /**
       * Calculates the value for a power law: Y = A * X^k.
       * This function is designed to represent the straight midline on a log-log plot.
       * @param {number} X - The independent variable (e.g., days since genesis).
       * @param {number} A_pl - The coefficient (pre-factor) of the power law.
       * @param {number} k_pl - The exponent of the power law.
       * @returns {number} The Y value according to the power law.
       */
      function calculatePowerLawValue(X, A_pl, k_pl) {
          // Ensure X is positive for Math.pow, especially if X can be 0 or negative
          if (X <= 0) return 0.001; // Return a small positive value to avoid errors in log scale
          return A_pl * Math.pow(X, k_pl);
      }

      /**
       * Calculates a sinusoidal wave value whose midline follows a power law.
       * The oscillation is applied as a multiplicative factor to the power law baseline.
       * Incorporates frequency and amplitude factor growth over time (logYear).
       * @param {number} X_days - The independent variable in days since genesis (for power law).
       * @param {number} year - The current year (for logYear calculations).
       * @param {number} startLogYear - The logYear value at the start of the plot (for relativeLogYear).
       * @param {number} amp_initial_factor - The initial fractional amplitude of oscillation (e.g., 0.1 for 10%).
       * This is a dimensionless factor.
       * @param {number} freq_initial - The initial frequency of the oscillation (cycles per logYear unit).
       * @param {number} phase - The phase offset of the oscillation.
       * @param {number} freq_growth_factor - Factor for frequency growth.
       * @param {number} amp_growth_factor - Factor for amplitude factor growth.
       * @param {number} amp_growth_strength - Strength for amplitude factor growth.
       * @param {number} powerLawAmp - The 'A' coefficient for the underlying power law midline.
       * @param {number} powerLawExponent - The 'k' exponent for the underlying power law midline.
       * @returns {number} The Y value of the wave, oscillating around the power law.
       */
      function calculateMultiplicativeWave(X_days, year, startLogYear,
                                           amp_initial_factor, freq_initial, phase,
                                           freq_growth_factor, amp_growth_factor, amp_growth_strength,
                                           powerLawAmp, powerLawExponent) {

          const powerLawMidlineValue = calculatePowerLawValue(X_days, powerLawAmp, powerLawExponent);

          let logYear = Math.log10(year - 1969);
          let relativeLogYear = logYear - startLogYear;

          // Calculate current frequency with growth
          let currentFreq = freq_initial * (1 + relativeLogYear * freq_growth_factor);
          if (currentFreq < 0.0001) currentFreq = 0.0001;

          // Calculate current amplitude factor with growth
          let currentAmpFactor = amp_initial_factor * Math.exp(relativeLogYear * amp_growth_factor * amp_growth_strength);
          currentAmpFactor = Math.max(0.000001, currentAmpFactor); // Keep minimum to avoid issues

          // Calculate the sinusoidal oscillation component
          let oscillationTerm = currentAmpFactor * Math.sin(2 * Math.PI * currentFreq * logYear + phase);

          // Apply oscillation multiplicatively to the power law midline
          // Ensure the overall multiplicative factor is positive to avoid log errors
          return powerLawMidlineValue * Math.max(0.001, (1 + oscillationTerm));
      }

      // GLOBAL VARIABLES for sinusoidal model parameters - now individual variables for clarity
      let wave1Freq, wave1Amp, wave1Phase, wave1FreqGrowth, wave1AmpGrowth, wave1AmpGrowthStrength, wave1PowerLawAmplitude, wave1PowerLawExponent;
      let wave2Freq, wave2Amp, wave2Phase, wave2FreqGrowth, wave2AmpGrowth, wave2AmpGrowthStrength, wave2PowerLawAmplitude, wave2PowerLawExponent;
      let wave3Freq, wave3Amp, wave3Phase, wave3FreqGrowth, wave3AmpGrowth, wave3AmpGrowthStrength, wave3PowerLawAmplitude, wave3PowerLawExponent;

      // Global variables for QCBD and Social Distrust
      let qcbDateYear, socialDistrustValue, qcbTransitionDuration, qcbCrashStrength, qcbAmplitudeDampening; 

      // Independent Power Law Parameters (Expected, Max, Min)
      let independentPowerLawAmplitude, independentPowerLawExponent;
      let independentPowerLawAmplitudeMax, independentPowerLawExponentMax;
      let independentPowerLawAmplitudeMin, independentPowerLawExponentMin;

      // Re-added: Global variables to store the BTC trace after it's fetched
      let btcTraceGlobal = null;
      let btcLogPricesGlobal = [];
      let btcDatesGlobal = []; // Stores formatted date strings (YYYY-MM-DD)
      let btcDaysSinceGenesisGlobal = []; // Stores days since genesis for BTC data

      // Global optimization parameters (can be tuned for better results)
      let optimizationLearningRate = 0.015; // Increased learning rate
      let optimizationIterations = 50; // Number of optimization cycles
      let optimizationParamPerturbation = 0.02; // Increased base perturbation

      /**
       * Initializes the input fields with the current global variable values.
       * This function is called once on page load to ensure UI consistency.
       */
      function initializeInputFields() {
          // QCBD Parameters
          qcbDateYear = 2034.2;
          socialDistrustValue = 100; 
          qcbTransitionDuration = 0.8;
          qcbCrashStrength = 1.2; 
          qcbAmplitudeDampening = 0.005; 
          document.getElementById('qcbDateInput').value = qcbDateYear.toFixed(3);
          document.getElementById('socialDistrustValueInput').value = socialDistrustValue.toFixed(3);
          document.getElementById('qcbTransitionInput').value = qcbTransitionDuration.toFixed(3);
          document.getElementById('qcbCrashStrengthInput').value = qcbCrashStrength.toFixed(3); 
          document.getElementById('qcbAmplitudeDampeningInput').value = qcbAmplitudeDampening.toFixed(3); 

          // Independent Power Law Parameters (Max) - Adjusted values
          independentPowerLawAmplitudeMax = 1.0e-13; 
          independentPowerLawExponentMax = 4.95; 
          document.getElementById('independentPowerLawAmplitudeMaxInput').value = independentPowerLawAmplitudeMax.toExponential(3); 
          document.getElementById('independentPowerLawExponentMaxInput').value = independentPowerLawExponentMax.toFixed(3);

          // Independent Power Law Parameters (Expected) - Adjusted values
          independentPowerLawAmplitude = 1.0e-17; 
          independentPowerLawExponent = 5.85; 
          document.getElementById('independentPowerLawAmplitudeInput').value = independentPowerLawAmplitude.toExponential(3); 
          document.getElementById('independentPowerLawExponentInput').value = independentPowerLawExponent.toFixed(3);

          // Independent Power Law Parameters (Min) - Adjusted values
          independentPowerLawAmplitudeMin = 1.0e-18; 
          independentPowerLawExponentMin = 6.00; 
          document.getElementById('independentPowerLawAmplitudeMinInput').value = independentPowerLawAmplitudeMin.toExponential(3); 
          document.getElementById('independentPowerLawExponentMinInput').value = independentPowerLawExponentMin.toFixed(3);


          // Wave 1 Parameters
          wave1Freq = 30.2; 
          wave1Amp = 0.92; // Corrected to fractional amplitude
          wave1Phase = 0.313;
          wave1FreqGrowth = 0.128; // Adjusted for more stable growth
          wave1AmpGrowth = 1.8; // Adjusted for more stable growth
          wave1AmpGrowthStrength = -0.5; // Adjusted initial value for broader exploration
          wave1PowerLawAmplitude = 3.500e-18;
          wave1PowerLawExponent = 5.850;
          document.getElementById('wave1FreqInput').value = wave1Freq.toFixed(3);
          document.getElementById('wave1AmpInput').value = wave1Amp.toFixed(3); // Updated to fixed(3) for factor
          document.getElementById('wave1PhaseInput').value = wave1Phase.toFixed(3);
          document.getElementById('wave1FreqGrowthInput').value = wave1FreqGrowth.toFixed(3);
          document.getElementById('wave1AmpGrowthInput').value = wave1AmpGrowth.toFixed(3);
          document.getElementById('wave1AmpGrowthStrengthInput').value = wave1AmpGrowthStrength.toFixed(3);
          document.getElementById('wave1PowerLawAmplitudeInput').value = wave1PowerLawAmplitude.toExponential(3);
          document.getElementById('wave1PowerLawExponentInput').value = wave1PowerLawExponent.toFixed(3);

          // Wave 2 Parameters
          wave2Freq = 40; 
          wave2Amp = 0.82; // Corrected to fractional amplitude
          wave2Phase = -0.644;
          wave2FreqGrowth = 0.396; // Adjusted
          wave2AmpGrowth = 1.9; // Adjusted
          wave2AmpGrowthStrength = -0.3; // Adjusted initial value
          wave2PowerLawAmplitude = 3.500e-18;
          wave2PowerLawExponent = 5.850;
          document.getElementById('wave2FreqInput').value = wave2Freq.toFixed(3);
          document.getElementById('wave2AmpInput').value = wave2Amp.toFixed(3);
          document.getElementById('wave2PhaseInput').value = wave2Phase.toFixed(3);
          document.getElementById('wave2FreqGrowthInput').value = wave2FreqGrowth.toFixed(3);
          document.getElementById('wave2AmpGrowthInput').value = wave2AmpGrowth.toFixed(3);
          document.getElementById('wave2AmpGrowthStrengthInput').value = wave2AmpGrowthStrength.toFixed(3);
          document.getElementById('wave2PowerLawAmplitudeInput').value = wave2PowerLawAmplitude.toExponential(3);
          document.getElementById('wave2PowerLawExponentInput').value = wave2PowerLawExponent.toFixed(3);

          // Wave 3 Parameters
          wave3Freq = 63.8;  
          wave3Amp = 0.72; // Corrected to fractional amplitude
          wave3Phase = 0.4;
          wave3FreqGrowth = 0.179; // Adjusted
          wave3AmpGrowth = 1.606; // Adjusted
          wave3AmpGrowthStrength = -0.1; // Adjusted initial value
          wave3PowerLawAmplitude = 3.500e-18;
          wave3PowerLawExponent = 5.850;
          document.getElementById('wave3FreqInput').value = wave3Freq.toFixed(3);
          document.getElementById('wave3AmpInput').value = wave3Amp.toFixed(3);
          document.getElementById('wave3PhaseInput').value = wave3Phase.toFixed(3);
          document.getElementById('wave3FreqGrowthInput').value = wave3FreqGrowth.toFixed(3);
          document.getElementById('wave3AmpGrowthInput').value = wave3AmpGrowth.toFixed(3);
          document.getElementById('wave3AmpGrowthStrengthInput').value = wave3AmpGrowthStrength.toFixed(3);
          document.getElementById('wave3PowerLawAmplitudeInput').value = wave3PowerLawAmplitude.toExponential(3);
          document.getElementById('wave3PowerLawExponentInput').value = wave3PowerLawExponent.toFixed(3);
      }
      
      /**
       * Calculates the value for the *separate* QCBD Crash line (red dashed).
       * This line visually represents the 'floor' or 'target' value the combined line
       * might crash towards after the QCBD year.
       * It's flat before QCBD year and then transitions to socialDistrustValue.
       * @param {number} year - The year for which to calculate the value.
       * @param {number} qcbYear - The QCBD year.
       * @param {number} socialDistrustVal - The social distrust value (the target floor).
       * @param {number} transitionDur - The transition duration in years.
       * @returns {number} The calculated value for the QCBD Crash line.
       */
      function getQCBDCrashLineValue(year, qcbYear, socialDistrustVal, transitionDur) {
          if (year < qcbYear) {
              return 0.001; // Effectively off the chart or minimal before QCBD
          } else {
              const transitionFactor = Math.min(1, (year - qcbYear) / transitionDur);
              // Smoothly transition from a low value to socialDistrustVal
              return 0.001 * (1 - transitionFactor) + socialDistrustVal * transitionFactor;
          }
      }

      /**
       * Calculates a transition factor (0 to 1) for the QCBD effect.
       * This factor determines how much the combined line transitions towards the socialDistrustValue.
       * @param {number} year - The current year.
       * @param {number} qcbYear - The QCBD year.
       * @param {number} transitionDur - The transition duration in years.
       * @param {number} crashStrength - The strength of the crash effect.
       * @returns {number} A factor between 0 and 1.
       */
      function getQCBDTransitionFactor(year, qcbYear, transitionDur, crashStrength) {
          const startTransition = qcbYear;
          const endTransition = qcbYear + transitionDur;

          if (year < startTransition) {
              return 0; // No effect yet
          } else if (year >= startTransition && year <= endTransition) {
              const t = (year - startTransition) / transitionDur;
              // Apply crash strength to accelerate the transition
              return Math.min(1, t * crashStrength); // Clamp to 1 to avoid overshooting
          } else {
              return 1; // Full effect applied
          }
      }
      
      /**
       * Helper function to generate combined data for a given set of parameters.
       * This is used by the fitting algorithm to test different parameter combinations
       * without affecting the global state during the optimization process.
       * This function now generates the full combined data without direct power law impact.
       * @param {object} params - An object containing all model parameters.
       * @returns {Array<number>} An array of combined Y-values for the simulated data.
       */
      function generateCombinedData(params) {
          let combinedData = [];
          const startPlotYear = 2015;
          const startLogYear = Math.log10(startPlotYear - 1969);

          // Loop through years from 2015 to 2035 with a step of 0.001 for more data points
          for (let year = 2015; year <= 2035; year = parseFloat((year + 0.001).toFixed(3))) { 
              let days = daysSinceGenesis(new Date(`${year}-01-01`)); // Use start of year for days for consistency
              if (days <= 0) days = 1; // Ensure days is positive for power law

              // New calculation for sum of waves following power law midline
              const startLogYearForGrowth = Math.log10(2015 - 1969);
              let sumOfWavesFollowingPowerLawMidline = 0;
              let totalOscillationFactorForQCBD = 0;

              // Parameters for the new wave functions - notice `amp` is now `amp_initial_factor`
              const waveParametersForNewModel = [
                  { amp_initial_factor: params.wave1Amp, freq_initial: params.wave1Freq, phase: params.wave1Phase,
                    freq_growth_factor: params.wave1FreqGrowth, amp_growth_factor: params.wave1AmpGrowth, amp_growth_strength: params.wave1AmpGrowthStrength,
                    powerLawAmp: params.wave1PowerLawAmplitude, powerLawExponent: params.wave1PowerLawExponent },
                  { amp_initial_factor: params.wave2Amp, freq_initial: params.wave2Freq, phase: params.wave2Phase,
                    freq_growth_factor: params.wave2FreqGrowth, amp_growth_factor: params.wave2AmpGrowth, amp_growth_strength: params.wave2AmpGrowthStrength,
                    powerLawAmp: params.wave2PowerLawAmplitude, powerLawExponent: params.wave2PowerLawExponent },
                  { amp_initial_factor: params.wave3Amp, freq_initial: params.wave3Freq, phase: params.wave3Phase,
                    freq_growth_factor: params.wave3FreqGrowth, amp_growth_factor: params.wave3AmpGrowth, amp_growth_strength: params.wave3AmpGrowthStrength,
                    powerLawAmp: params.wave3PowerLawAmplitude, powerLawExponent: params.wave3PowerLawExponent }
              ];

              for (let i = 0; i < 3; i++) {
                  let currentWaveConfig = waveParametersForNewModel[i];

                  // Calculate the individual wave based on its specific power law midline
                  let currentWaveValue = calculateMultiplicativeWave(
                      days,
                      year,
                      startLogYearForGrowth,
                      currentWaveConfig.amp_initial_factor,
                      currentWaveConfig.freq_initial,
                      currentWaveConfig.phase,
                      currentWaveConfig.freq_growth_factor,
                      currentWaveConfig.amp_growth_factor,
                      currentWaveConfig.amp_growth_strength,
                      currentWaveConfig.powerLawAmp,   // Use wave-specific power law amplitude
                      currentWaveConfig.powerLawExponent // Use wave-specific power law exponent
                  );

                  sumOfWavesFollowingPowerLawMidline += currentWaveValue;

                  // Also calculate the oscillation factor for QCBD dampening
                  let logYearForOsc = Math.log10(year - 1969);
                  let relativeLogYearForOsc = logYearForOsc - startLogYearForGrowth;
                  let currentFreqForOsc = currentWaveConfig.freq_initial * (1 + relativeLogYearForOsc * currentWaveConfig.freq_growth_factor);
                  let currentAmpFactorForOsc = currentWaveConfig.amp_initial_factor * Math.exp(relativeLogYearForOsc * currentWaveConfig.amp_growth_factor * currentWaveConfig.amp_growth_strength);
                  currentAmpFactorForOsc = Math.max(0.000001, currentAmpFactorForOsc); // Removed upper clamp

                  totalOscillationFactorForQCBD += currentAmpFactorForOsc * Math.sin(2 * Math.PI * currentFreqForOsc * logYearForOsc + currentWaveConfig.phase);
              }


              let finalCombinedValue;

              if (year < params.qcbDateYear) {
                  finalCombinedValue = sumOfWavesFollowingPowerLawMidline;
              } else {
                  const transitionFactor = getQCBDTransitionFactor(year, params.qcbDateYear, params.qcbTransitionDuration, params.qcbCrashStrength);

                  // Dampen the total multiplicative oscillation factor
                  let dampenedTotalOscillationFactor = totalOscillationFactorForQCBD * (1 - transitionFactor * (1 - params.qcbAmplitudeDampening));

                  // The target value now incorporates the dampened oscillations multiplicatively
                  let targetCrashValue = params.socialDistrustValue * (1 + dampenedTotalOscillationFactor);

                  // Blend the normal combined wave with the crashing target
                  finalCombinedValue = sumOfWavesFollowingPowerLawMidline * (1 - transitionFactor) + targetCrashValue * transitionFactor;
              }
              
              combinedData.push(Math.max(0.001, finalCombinedValue));
          }
          return combinedData;
      }

      /**
       * Calculates the Mean Squared Error (MSE) between simulated and actual BTC log prices.
       * This function quantifies how well the simulated curve fits the real data.
       * It compares the logarithm of the simulated values to the logarithm of the BTC values.
       * @param {Array<number>} simulatedData - The Y-values of the simulated combined curve.
       * @param {Array<number>} actualLogPrices - The logarithm of the actual BTC prices.
       * @returns {number} The Mean Squared Error. Returns Infinity if no valid data points for comparison.
       */
      function calculateModelError(simulatedData, actualLogPrices) {
          let error = 0;
          let count = 0;

          const minLen = Math.min(simulatedData.length, actualLogPrices.length);

          for (let i = 0; i < minLen; i++) {
              if (simulatedData[i] > 0) {
                  const logSimulated = Math.log(simulatedData[i]);
                  if (isFinite(actualLogPrices[i])) {
                      error += Math.pow(logSimulated - actualLogPrices[i], 2);
                      count++;
                  }
              }
          }
          return count > 0 ? error / count : Infinity;
      }


      /**
       * Asynchronously fetches Bitcoin (BTCUSDT) weekly closing prices from Binance API.
       * It then creates a Plotly trace for this data, stores it globally, and
       * triggers a full redraw of the graph including the BTC data.
       */
      async function myAddBitcoinToPlot() {
          const url = 'https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1w&limit=3000';
        //  const url = 'https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1M';
          try {
              document.getElementById('statusMessage').innerText = 'Fetching BTC data...';
              const response = await fetch(url);
              const data = await response.json();

              // Clear previous BTC data arraysFvisible
              btcDatesGlobal = [];
              btcDaysSinceGenesisGlobal = [];
              btcLogPricesGlobal = [];

            //// Create a reversed copy
             //const reversedArray = originalArray.slice().reverse();
              const dataReverse = data.slice().reverse();

              dataReverse.forEach(candle => {
            //  data.forEach(candle => {
                  const date = new Date(candle[0]); // Unix timestamp to Date object
                  const days = daysSinceGenesis(date); // Calculate days since genesis
                  const price = parseFloat(candle[4]); // Closing price

                  btcDatesGlobal.push(date.toISOString().split('T')[0]); // Store formatted date string
                  btcDaysSinceGenesisGlobal.push(days); // Store days since genesis
                  btcLogPricesGlobal.push(Math.log(price)); // Store log price
              });
            // add the historical bitcoin 2011 to 2018
         //   console.log('earlyDates.length')
          //  console.log(earlyDates.length)




            
        //    for (let myI=0; myI < earlyDates.length; myI++){
            for (let myI=earlyDates.length; myI > 0 ; myI--){
                btcDatesGlobal.push(earlyDates[myI])
                btcDaysSinceGenesisGlobal.push(earlyDaysSinceGenesis[myI]); // Store days since genesis
                btcLogPricesGlobal.push(earlyLogPrices[myI]); // Store log price          
            }

              btcTraceGlobal = {
                  x: btcDaysSinceGenesisGlobal, // Use days since genesis for x-axis
                  y: btcDatesGlobal.map((_, i) => btcLogPricesGlobal[i]), // Use log prices for y-axis
                  mode: 'lines',
                  line: { color: 'orange', width: 3 },
                  name: 'BTC Price (USD)'
              };

              myGenerateLogLogData();
              document.getElementById('statusMessage').innerText = '✅ Bitcoin data added to plot.';
              console.log('✅ Bitcoin data added to plot.');
          } catch (err) {
              btcTraceGlobal = null; 
              document.getElementById('statusMessage').innerText = '❌ Failed to load BTC data.';
              console.error('❌ Failed to load BTC data:', err);
          }
      }

    

      /**
       * Generates and plots sinusoidal growth data on a log-log scale.
       * The function calculates three individual waves and a combined sum,
       * applying exponential growth to both amplitude and frequency,
       * and an.
       * This function now also includes the global BTC trace if it exists.
       */
      function myGenerateLogLogData() {
        let xData = []; // Will store days since genesis for the log x-axis
        let displayDates = []; // Will store formatted dates for hover info
        let myCombined = []; 
        let myWaves = [[], [], []];
        let qcbCrashLineData = []; 
        let independentPowerLawData = []; 
        let independentPowerLawDataMax = []; 
        let independentPowerLawDataMin = []; 

        // Define the start and end dates for data generation
        const dataGenStartDate = new Date('2011-01-01T00:00:00Z'); // Data generation starts from 2011
        const dataGenEndDate = new Date('2040-12-31T00:00:00Z'); // Extend data generation to 2040

        // Define the start date for displaying the graph
        const graphDisplayStartDate = new Date('2011-01-01T00:00:00Z');

        let currentDate = new Date(dataGenStartDate);
        while (currentDate <= dataGenEndDate) {
            const days = daysSinceGenesis(currentDate);
            
            // Only push data to arrays if it's within the display range
            if (currentDate >= graphDisplayStartDate) {
                xData.push(days); // Use days for the log x-axis
                displayDates.push(currentDate.toISOString().split('T')[0]); // Store formatted date as McClellan-MM-DD for display
            }

            const year = currentDate.getFullYear() + (currentDate.getMonth() / 12); // Approximate year for calculations
            const logYear = Math.log10(year - 1969); // Log of years since 1969 for power law

            // --- REPLACED CODE BLOCK START ---
            const startLogYearForGrowth = Math.log10(2015 - 1969); // Consistent with original growth calculation
            let sumOfWavesFollowingPowerLawMidline = 0; // New sum for our corrected waves (equivalent to old sumOfFullIndividualWaveComponents)
            let totalOscillationFactorForQCBD = 0; // To collect the (amplitude_factor * sin) terms for QCBD dampening

            // Parameters for the new wave functions - notice `amp` is now `amp_initial_factor`
            const waveParametersForNewModel = [
                  { amp_initial_factor: wave1Amp, freq_initial: wave1Freq, phase: wave1Phase,
                    freq_growth_factor: wave1FreqGrowth, amp_growth_factor: wave1AmpGrowth, amp_growth_strength: wave1AmpGrowthStrength,
                    powerLawAmp: wave1PowerLawAmplitude, powerLawExponent: wave1PowerLawExponent },
                  { amp_initial_factor: wave2Amp, freq_initial: wave2Freq, phase: wave2Phase,
                    freq_growth_factor: wave2FreqGrowth, amp_growth_factor: wave2AmpGrowth, amp_growth_strength: wave2AmpGrowthStrength,
                    powerLawAmp: wave2PowerLawAmplitude, powerLawExponent: wave2PowerLawExponent },
                  { amp_initial_factor: wave3Amp, freq_initial: wave3Freq, phase: wave3Phase, 
                    freq_growth_factor: wave3FreqGrowth, amp_growth_factor: wave3AmpGrowth, amp_growth_strength: wave3AmpGrowthStrength,
                    powerLawAmp: wave3PowerLawAmplitude, powerLawExponent: wave3PowerLawExponent }
            ];

            for (let i = 0; i < 3; i++) {
                let currentWaveConfig = waveParametersForNewModel[i];

                // Calculate the individual wave based on its specific power law midline
                let currentWaveValue = calculateMultiplicativeWave(
                    days,
                    year,
                    startLogYearForGrowth,
                    currentWaveConfig.amp_initial_factor,
                    currentWaveConfig.freq_initial,
                    currentWaveConfig.phase,
                    currentWaveConfig.freq_growth_factor,
                    currentWaveConfig.amp_growth_factor,
                    currentWaveConfig.amp_growth_strength,
                    currentWaveConfig.powerLawAmp,   // Use wave-specific power law amplitude
                    currentWaveConfig.powerLawExponent // Use wave-specific power law exponent
                );

                sumOfWavesFollowingPowerLawMidline += currentWaveValue;

                // Also calculate the oscillation factor for QCBD dampening
                let logYearForOsc = Math.log10(year - 1969);
                let relativeLogYearForOsc = logYearForOsc - startLogYearForGrowth;
                let currentFreqForOsc = currentWaveConfig.freq_initial * (1 + relativeLogYearForOsc * currentWaveConfig.freq_growth_factor);
                let currentAmpFactorForOsc = currentWaveConfig.amp_initial_factor * Math.exp(relativeLogYearForOsc * currentWaveConfig.amp_growth_factor * currentWaveConfig.amp_growth_strength);
                currentAmpFactorForOsc = Math.max(0.000001, currentAmpFactorForOsc); // Removed upper clamp

                totalOscillationFactorForQCBD += currentAmpFactorForOsc * Math.sin(2 * Math.PI * currentFreqForOsc * logYearForOsc + currentWaveConfig.phase);

                // Only push data to arrays if it's within the display range
                if (currentDate >= graphDisplayStartDate) {
                    myWaves[i].push(Math.max(0.001, currentWaveValue)); // Ensure values are positive for log plot
                }
            }
            // --- REPLACED CODE BLOCK END ---


            // Independent Power Law calculations using 'days' for x-axis
            let currentPowerLawValue = independentPowerLawAmplitude * Math.pow(days, independentPowerLawExponent);
            if (currentPowerLawValue <= 0) currentPowerLawValue = 0.001;
            if (currentPowerLawValue > 1e10) currentPowerLawValue = 1e10; 
            // Only push data to arrays if it's within the display range
            if (currentDate >= graphDisplayStartDate) {
                independentPowerLawData.push(currentPowerLawValue);
            }

            let currentPowerLawValueMax = independentPowerLawAmplitudeMax * Math.pow(days, independentPowerLawExponentMax);
            if (currentPowerLawValueMax <= 0) currentPowerLawValueMax = 0.001;
            if (currentPowerLawValueMax > 1e10) currentPowerLawValueMax = 1e10;
            // Only push data to arrays if it's within the display range
            if (currentDate >= graphDisplayStartDate) {
                independentPowerLawDataMax.push(currentPowerLawValueMax);
            }

            let currentPowerLawValueMin = independentPowerLawAmplitudeMin * Math.pow(days, independentPowerLawExponentMin);
            if (currentPowerLawValueMin <= 0) currentPowerLawValueMin = 0.001;
            if (currentPowerLawValueMin > 1e10) currentPowerLawValueMin = 1e10;
            // Only push data to arrays if it's within the display range
            if (currentDate >= graphDisplayStartDate) {
                independentPowerLawDataMin.push(currentPowerLawValueMin);
            }


            const qcbLineValueForPlot = getQCBDCrashLineValue(year, qcbDateYear, socialDistrustValue, qcbTransitionDuration);
            // Only push data to arrays if it's within the display range
            if (currentDate >= graphDisplayStartDate) {
                qcbCrashLineData.push(qcbLineValueForPlot); 
            }

            let finalCombinedValue;

            // --- REPLACED QCBD FINAL COMBINED VALUE LOGIC START ---
            if (year < qcbDateYear) {
                finalCombinedValue = sumOfWavesFollowingPowerLawMidline;
            } else {
                const transitionFactor = getQCBDTransitionFactor(year, qcbDateYear, qcbTransitionDuration, qcbCrashStrength);

                // Dampen the total multiplicative oscillation factor
                let dampenedTotalOscillationFactor = totalOscillationFactorForQCBD * (1 - transitionFactor * (1 - qcbAmplitudeDampening));

                // The target value now incorporates the dampened oscillations multiplicatively
                let targetCrashValue = socialDistrustValue * (1 + dampenedTotalOscillationFactor);

                // Blend the normal combined wave with the crashing target
                finalCombinedValue = sumOfWavesFollowingPowerLawMidline * (1 - transitionFactor) + targetCrashValue * transitionFactor;
            }
            // --- REPLACED QCBD FINAL COMBINED VALUE LOGIC END ---
            
            // Only push data to arrays if it's within the display range
            if (currentDate >= graphDisplayStartDate) {
                myCombined.push(Math.max(0.001, finalCombinedValue));
            }

            currentDate.setDate(currentDate.getDate() + 30); // Increment by 30 days
        }

        let myTraces = myWaves.map((wave, i) => ({
          x: xData,
          y: wave,
          mode: 'lines',
          line: { color: 'green', width: 1 }, 
          name: 'Wave ' + (i + 1),
          visible: 'legendonly',   
          hovertemplate: '<b>Date:</b> %{customdata}<br><b>Days:</b> %{x}<br><b>Price:</b> %{y:$,.2f}<extra></extra>',
          customdata: displayDates
        }));

        myTraces.push({
          x: xData,
          y: myCombined,
          mode: 'lines',
          line: { color: 'blue', width: 3 },
          name: 'Combined',
          hovertemplate: '<b>Date:</b> %{customdata}<br><b>Days:</b> %{x}<br><b>Price:</b> %{y:$,.2f}<extra></extra>',
          customdata: displayDates
        });

        myTraces.push({
            x: xData,
            y: independentPowerLawData,
            mode: 'lines',
            line: { color: 'yellow', width: 3, dash: 'solid' }, 
            name: 'Expected Independent Power Law',
            hovertemplate: '<b>Date:</b> %{customdata}<br><b>Days:</b> %{x}<br><b>Price:</b> %{y:$,.2f}<extra></extra>',
            customdata: displayDates
        });
        myTraces.push({
            x: xData,
            y: independentPowerLawDataMax,
            mode: 'lines',
            line: { color: 'gold', width: 1, dash: 'dash' }, 
            name: 'Max Independent Power Law',
            hovertemplate: '<b>Date:</b> %{customdata}<br><b>Days:</b> %{x}<br><b>Price:</b> %{y:$,.2f}<extra></extra>',
            customdata: displayDates
        });
        myTraces.push({
            x: xData,
            y: independentPowerLawDataMin,
            mode: 'lines',
            line: { color: 'goldenrod', width: 1, dash: 'dash' }, 
            name: 'Min Independent Power Law',
            hovertemplate: '<b>Date:</b> %{customdata}<br><b>Days:</b> %{x}<br><b>Price:</b> %{y:$,.2f}<extra></extra>',
            customdata: displayDates
        });


        myTraces.push({
            x: xData, 
            y: qcbCrashLineData,
            mode: 'lines',
            line: { color: 'red', width: 3, dash: 'dashdot' }, 
            name: 'QCBD Crash Line',
            hovertemplate: '<b>Date:</b> %{customdata}<br><b>Days:</b> %{x}<br><b>Price:</b> %{y:$,.2f}<extra></extra>',
            customdata: displayDates
        });

        // Re-added: BTC trace addition
        if (btcTraceGlobal) {
            const filteredBtcX = [];
            const filteredBtcY = [];
            const filteredBtcDisplayDates = [];
            
            // Filter BTC data based on the new x-axis display range (days since genesis)
            const startDaysDisplay = daysSinceGenesis(graphDisplayStartDate);
            const endDaysDisplay = daysSinceGenesis(dataGenEndDate); // Use dataGenEndDate for BTC filtering as well

            for (let i = 0; i < btcDaysSinceGenesisGlobal.length; i++) {
                const btcDays = btcDaysSinceGenesisGlobal[i];

                if (btcDays >= startDaysDisplay && btcDays <= endDaysDisplay) {
                    filteredBtcX.push(btcDays);
                    filteredBtcY.push(Math.exp(btcLogPricesGlobal[i])); // Convert log price back to actual price for plotting
                    filteredBtcDisplayDates.push(btcDatesGlobal[i]);
                }
            }
            myTraces.push({
                x: filteredBtcX,
                y: filteredBtcY,
                mode: 'lines',
                line: { color: 'orange', width: 3 },
                name: 'BTC Price (USD)',
                hovertemplate: '<b>Date:</b> %{customdata}<br><b>Days:</b> %{x}<br><b>Price:</b> %{y:$,.2f}<extra></extra>',
                customdata: filteredBtcDisplayDates
            });
        }

        // Generate tick values and text for years dynamically based on the display range
        const tickYears = [];
        const tickDays = [];
        for (let year = graphDisplayStartDate.getFullYear(); year <= dataGenEndDate.getFullYear(); year++) {
            tickYears.push(year.toString());
            tickDays.push(daysSinceGenesis(new Date(`${year}-01-01`)));
        }


        let myLayout = {
          title: 'Vibe Coding BTC Sinusoids',
          xaxis: {
            title: 'Days Since Genesis (Log Scale)', // Reverted x-axis title
            type: 'log',
            // Define custom tick values and text for years starting from 2017 and extending
            tickvals: tickDays,
            ticktext: tickYears,
            tickangle: 45, // Angle the x-axis ticks at 45 degrees
            range: [Math.log10(daysSinceGenesis(graphDisplayStartDate)), Math.log10(daysSinceGenesis(dataGenEndDate))], // Set display range
            gridcolor: '#e0e0e0', // Light grey grid lines
            linecolor: '#cccccc', // Axis line color
            linewidth: 1,
            mirror: true,
            rangeslider: { visible: true },
            rangeselector: {
                buttons: [
                    { count: 1, label: '1y', step: 'year', stepmode: 'backward' },
                    { count: 5, label: '5y', step: 'year', stepmode: 'backward' },
                    { step: 'all' }
                ]
            }
          },
          yaxis: {
            title: 'Simulated Dollars (Log Scale)',
            type: 'log',
            range: [0, 7] 
          },
          margin: { t: 40 }
        };

        Plotly.newPlot('myPlot', myTraces, myLayout);
      }


      /**
       * Performs a simple linear regression to find slope and intercept.
       * @param {Array<number>} xData - Array of x values.
       * @param {Array<number>} yData - Array of y values.
       * @returns {{slope: number, intercept: number}} The calculated slope and intercept.
       */
      function linearRegression(xData, yData) {
          let N = xData.length;
          let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;

          for (let i = 0; i < N; i++) {
              sumX += xData[i];
              sumY += yData[i];
              sumXY += xData[i] * xData[i];
              sumXX += xData[i] * xData[i];
          }

          let slope = (N * sumXY - sumX * sumY) / (N * sumXX - sumX * sumX);
          let intercept = (sumY - slope * sumX) / N;

          return { slope, intercept };
      }



      async function myOpto(myVal){
        for(let myLoop = 0; myLoop < myVal; myLoop++){
            await  optimizeModel(myLoop)
       }
    
      }


      
      /**
       * Optimizes the model parameters to minimize the error between the combined curve
       * and the actual BTC price data. This uses a simple iterative gradient descent-like approach.
       * @param {number} myRepeats - An integer passed to the optimization function to indicate the repetition count.
       */
      async function optimizeModel(myRepeats) {
          if (!btcTraceGlobal || btcLogPricesGlobal.length === 0) {
              document.getElementById('statusMessage').innerText = 'Please load BTC data first by refreshing the page.';
              return;
          }

          document.getElementById('statusMessage').innerText = 'Optimizing model... this may take a moment.';

          let currentParams = {
              qcbDateYear: qcbDateYear,
              socialDistrustValue: socialDistrustValue,
              qcbTransitionDuration: qcbTransitionDuration,
              qcbCrashStrength: qcbCrashStrength,
              qcbAmplitudeDampening: qcbAmplitudeDampening,
              wave1Freq: wave1Freq, wave1Amp: wave1Amp, wave1Phase: wave1Phase,
              wave1FreqGrowth: wave1FreqGrowth, wave1AmpGrowth: wave1AmpGrowth, wave1AmpGrowthStrength: wave1AmpGrowthStrength,
              wave1PowerLawAmplitude: wave1PowerLawAmplitude, wave1PowerLawExponent: wave1PowerLawExponent,
              wave2Freq: wave2Freq, wave2Amp: wave2Amp, wave2Phase: wave2Phase,
              wave2FreqGrowth: wave2FreqGrowth, wave2AmpGrowth: wave2AmpGrowth, wave2AmpGrowthStrength: wave2AmpGrowthStrength,
              wave2PowerLawAmplitude: wave2PowerLawAmplitude, wave2PowerLawExponent: wave2PowerLawExponent,
              wave3Freq: wave3Freq, wave3Amp: wave3Amp, wave3Phase: wave3Phase,
              wave3FreqGrowth: wave3FreqGrowth, wave3AmpGrowth: wave3AmpGrowth, wave3AmpGrowthStrength: wave3AmpGrowthStrength,
              wave3PowerLawAmplitude: wave3PowerLawAmplitude, wave3PowerLawExponent: wave3PowerLawExponent
          };

          let bestError = Infinity;
          let bestParams = { ...currentParams };

          // Get the actual BTC log prices for comparison, filtering for the relevant date range
          // This assumes `btcDatesGlobal` and `btcLogPricesGlobal` are aligned
          const dataGenStartDate = new Date('2015-01-01T00:00:00Z'); // Optimization starts from 2015 data
          const startIndex = btcDatesGlobal.findIndex(dateStr => new Date(dateStr) >= dataGenStartDate);
          const actualLogPrices = btcLogPricesGlobal.slice(startIndex);


          const paramNames = Object.keys(currentParams);
          const initialLearningRate = optimizationLearningRate;
          const absolutePerturbationBase = 0.05; // A small absolute amount to ensure movement

          for (let iteration = 0; iteration < optimizationIterations; iteration++) {
              let currentLearningRate = initialLearningRate * (1 - iteration / optimizationIterations); // Decrease learning rate
              if (currentLearningRate < 0.000001) currentLearningRate = 0.000001; // Minimum learning rate

              let iterationImproved = false;

              // Shuffle parameter order to avoid bias
              paramNames.sort(() => Math.random() - 0.5);

              for (const paramName of paramNames) {
                  const originalValue = currentParams[paramName];
                  let currentBestForParam = originalValue;

                  // Calculate current error before any perturbation for this parameter
                  let simulatedData = generateCombinedData(currentParams);
                  let currentError = calculateModelError(simulatedData, actualLogPrices);

                  // Update overall best if current state is better
                  if (currentError < bestError) {
                      bestError = currentError;
                      bestParams = { ...currentParams };
                      iterationImproved = true;
                  }

                  let perturbationMagnitude;
                  if (paramName.includes('Phase')) {
                      // Absolute perturbation for phase, as it can be 0 or small
                      perturbationMagnitude = currentLearningRate * 0.2; // Larger fixed radian step
                  } else if (paramName.includes('Freq')) {
                      // Specific perturbation for frequency to allow more granular changes
                      perturbationMagnitude = currentLearningRate * (Math.abs(originalValue) * 0.01 + 0.1); // Slightly larger absolute component
                  }
                  else if (paramName.includes('AmpGrowthStrength')) {
                      // Specific perturbation for AmpGrowthStrength to allow greater exploration
                      perturbationMagnitude = currentLearningRate * (Math.abs(originalValue) * 0.1 + 0.5); // More aggressive absolute component
                  }
                   else if (paramName.includes('PowerLawExponent')) { // Explicitly target PowerLawExponent
                      // Proportional perturbation for exponent, reduced by a third
                      perturbationMagnitude = Math.max(
                          Math.abs(originalValue) * currentLearningRate * optimizationParamPerturbation * (2/3), // Reduced by a third
                          1e-10 // A very small absolute floor
                      );
                  }
                   else if (paramName.includes('PowerLawAmplitude')) {
                      // Proportional perturbation for large/small amplitudes, with a floor
                      perturbationMagnitude = Math.max(
                          Math.abs(originalValue) * currentLearningRate * optimizationParamPerturbation,
                          1e-20 // A very small absolute floor for amplitude
                      );
                  } else {
                      // For other numerical parameters, a blend of relative and absolute
                      perturbationMagnitude = currentLearningRate * (Math.abs(originalValue) * optimizationParamPerturbation + absolutePerturbationBase);
                  }

                  // Test positive perturbation
                  let valPlus = originalValue + perturbationMagnitude;
                  // Add boundary checks for reasonable values
                  if (paramName.includes('Amp') && !paramName.includes('PowerLaw')) valPlus = Math.max(0.000001, valPlus);
                  if (paramName.includes('PowerLawAmplitude')) valPlus = Math.max(1e-25, valPlus); // Prevent extreme small/negative
                  if (paramName.includes('socialDistrustValue')) valPlus = Math.max(1, valPlus); // Social distrust must be positive
                  if (paramName.includes('Year')) valPlus = Math.max(2020, Math.min(2040, valPlus)); // Keep year reasonable
                  if (paramName.includes('Duration')) valPlus = Math.max(0.01, valPlus); // Duration must be positive
                  if (paramName.includes('Freq') && !paramName.includes('Growth')) valPlus = Math.max(0.01, valPlus); // Frequencies should be positive and not too small
                  // No specific upper bound for AmpGrowthStrength for now, allow it to explore
                  // Other parameters don't have hard upper bounds beyond what the math naturally handles


                  currentParams[paramName] = valPlus;
                  simulatedData = generateCombinedData(currentParams);
                  let errorPlus = calculateModelError(simulatedData, actualLogPrices);

                  // Test negative perturbation
                  let valMinus = originalValue - perturbationMagnitude;
                  // Add boundary checks
                  if (paramName.includes('Amp') && !paramName.includes('PowerLaw')) valMinus = Math.max(0.000001, valMinus);
                  if (paramName.includes('PowerLawAmplitude')) valMinus = Math.max(1e-25, valMinus);
                  if (paramName.includes('socialDistrustValue')) valMinus = Math.max(1, valMinus);
                  if (paramName.includes('Year')) valMinus = Math.max(2020, Math.min(2040, valMinus));
                  if (paramName.includes('Duration')) valMinus = Math.max(0.01, valMinus);
                  if (paramName.includes('Freq') && !paramName.includes('Growth')) valMinus = Math.max(0.01, valMinus); // Frequencies should be positive and not too small


                  currentParams[paramName] = valMinus;
                  simulatedData = generateCombinedData(currentParams);
                  let errorMinus = calculateModelError(simulatedData, actualLogPrices);

                  // Decide which direction is better
                  if (errorPlus < currentError && errorPlus < errorMinus) {
                      currentBestForParam = valPlus;
                      iterationImproved = true;
                  } else if (errorMinus < currentError && errorMinus < errorPlus) {
                      currentBestForParam = valMinus;
                      iterationImproved = true;
                  } else {
                      currentBestForParam = originalValue; // Stick with original if no improvement
                  }
                  currentParams[paramName] = currentBestForParam; // Apply the best value for this param
              }

              // Update the best parameters for the next iteration
              Object.assign(currentParams, bestParams); // Revert to the overall best parameters found so far for the next iteration's starting point

              if (!iterationImproved && currentLearningRate < 0.000001) { // Stop if no improvement and learning rate is very small
                  break;
              }

              // Optional: Update UI periodically to show progress
              if (iteration % 4 === 0 || iteration === optimizationIterations - 1) {
                  document.getElementById('statusMessage').innerText = `Count:${myRepeats}, Optimizing... Iteration ${iteration + 1}/${optimizationIterations}, Current Best Error: ${bestError.toFixed(3)}`;
                  // Re-plot to show intermediate results (can be slow, comment out if needed for speed)
                  // updateInputFieldsWithOptimizedParams(bestParams);
                  // myGenerateLogLogData();
                  // await new Promise(r => setTimeout(r, 50)); // Small delay to allow UI refresh
              }
              await new Promise(r => setTimeout(r, 0)); // Yield to UI
          }

          // Apply the very best parameters found at the end
          updateInputFieldsWithOptimizedParams(bestParams);
          myGenerateLogLogData(); // Final plot update

          document.getElementById('statusMessage').innerText = `Count:${myRepeats+1}, Optimization complete! Final Error: ${bestError.toFixed(3)}`;
          console.log("Optimization finished. Best parameters:", bestParams);
          console.log(`Repeats ${myRepeats+1}, Final Error ${bestError}`);
      }

      /**
       * Updates the input fields with the optimized parameters.
       * @param {object} params - The object containing the optimized parameter values.
       */
      function updateInputFieldsWithOptimizedParams(params) {
          // QCBD Parameters
          qcbDateYear = params.qcbDateYear;
          socialDistrustValue = params.socialDistrustValue;
          qcbTransitionDuration = params.qcbTransitionDuration;
          qcbCrashStrength = params.qcbCrashStrength;
          qcbAmplitudeDampening = params.qcbAmplitudeDampening;
          document.getElementById('qcbDateInput').value = qcbDateYear.toFixed(3);
          document.getElementById('socialDistrustValueInput').value = socialDistrustValue.toFixed(3);
          document.getElementById('qcbTransitionInput').value = qcbTransitionDuration.toFixed(3);
          document.getElementById('qcbCrashStrengthInput').value = qcbCrashStrength.toFixed(3);
          document.getElementById('qcbAmplitudeDampeningInput').value = qcbAmplitudeDampening.toFixed(3);

          // Wave 1 Parameters
          wave1Freq = params.wave1Freq; wave1Amp = params.wave1Amp; wave1Phase = params.wave1Phase;
          wave1FreqGrowth = params.wave1FreqGrowth; wave1AmpGrowth = params.wave1AmpGrowth; wave1AmpGrowthStrength = params.wave1AmpGrowthStrength;
          wave1PowerLawAmplitude = params.wave1PowerLawAmplitude; wave1PowerLawExponent = params.wave1PowerLawExponent;
          document.getElementById('wave1FreqInput').value = wave1Freq.toFixed(3);
          document.getElementById('wave1AmpInput').value = wave1Amp.toFixed(3);
          document.getElementById('wave1PhaseInput').value = wave1Phase.toFixed(3);
          document.getElementById('wave1FreqGrowthInput').value = wave1FreqGrowth.toFixed(3);
          document.getElementById('wave1AmpGrowthInput').value = wave1AmpGrowth.toFixed(3);
          document.getElementById('wave1AmpGrowthStrengthInput').value = wave1AmpGrowthStrength.toFixed(3);
          document.getElementById('wave1PowerLawAmplitudeInput').value = wave1PowerLawAmplitude.toExponential(3);
          document.getElementById('wave1PowerLawExponentInput').value = wave1PowerLawExponent.toFixed(3);

          // Wave 2 Parameters
          wave2Freq = params.wave2Freq; wave2Amp = params.wave2Amp; wave2Phase = params.wave2Phase;
          wave2FreqGrowth = params.wave2FreqGrowth; wave2AmpGrowth = params.wave2AmpGrowth; wave2AmpGrowthStrength = params.wave2AmpGrowthStrength;
          wave2PowerLawAmplitude = params.wave2PowerLawAmplitude; wave2PowerLawExponent = params.wave2PowerLawExponent;
          document.getElementById('wave2FreqInput').value = wave2Freq.toFixed(3);
          document.getElementById('wave2AmpInput').value = wave2Amp.toFixed(3);
          document.getElementById('wave2PhaseInput').value = wave2Phase.toFixed(3);
          document.getElementById('wave2FreqGrowthInput').value = wave2FreqGrowth.toFixed(3);
          document.getElementById('wave2AmpGrowthInput').value = wave2AmpGrowth.toFixed(3);
          document.getElementById('wave2AmpGrowthStrengthInput').value = wave2AmpGrowthStrength.toFixed(3);
          document.getElementById('wave2PowerLawAmplitudeInput').value = wave2PowerLawAmplitude.toExponential(3);
          document.getElementById('wave2PowerLawExponentInput').value = wave2PowerLawExponent.toFixed(3);

          // Wave 3 Parameters
          wave3Freq = params.wave3Freq; wave3Amp = params.wave3Amp; wave3Phase = params.wave3Phase;
          wave3FreqGrowth = params.wave3FreqGrowth; wave3AmpGrowth = params.wave3AmpGrowth; wave3AmpGrowthStrength = params.wave3AmpGrowthStrength;
          wave3PowerLawAmplitude = params.wave3PowerLawAmplitude; wave3PowerLawExponent = params.wave3PowerLawExponent;
          document.getElementById('wave3FreqInput').value = wave3Freq.toFixed(3);
          document.getElementById('wave3AmpInput').value = wave3Amp.toFixed(3);
          document.getElementById('wave3PhaseInput').value = wave3Phase.toFixed(3);
          document.getElementById('wave3FreqGrowthInput').value = wave3FreqGrowth.toFixed(3);
          document.getElementById('wave3AmpGrowthInput').value = wave3AmpGrowth.toFixed(3);
          document.getElementById('wave3AmpGrowthStrengthInput').value = wave3AmpGrowthStrength.toFixed(3);
          document.getElementById('wave3PowerLawAmplitudeInput').value = wave3PowerLawAmplitude.toExponential(3);
          document.getElementById('wave3PowerLawExponentInput').value = wave3PowerLawExponent.toFixed(3);
      }
   

      // Initialize on page load
      document.addEventListener('DOMContentLoaded', () => {
          initializeInputFields();
          myAddBitcoinToPlot(); // Fetch BTC data on load
      });







    const earlyDates = ["2010-12-31","2011-01-01","2011-01-02"];
   const earlyDaysSinceGenesis = [727,728,729];
   const earlyLogPrices = [-1.2039728043259361,-1.2039728043259361,-1.2039728043259361];
    </script>
  </body>
</html>
